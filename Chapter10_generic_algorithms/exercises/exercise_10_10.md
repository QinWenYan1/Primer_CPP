# 📘 C++ 练习题评价

## 📋 总体概览

| 题目 | 得分 | 评价摘要 |
|------|------|----------|
| 10.10 | ⭐⭐⭐ (3/5) | 核心观点正确，但缺少设计意图的深度阐述 |

---

## 🎯 逐题详细评价

### Exercise 10.10 算法设计哲学分析

**原题：** Why do you think the algorithms don’t change the size of containers?

**你的答案：**
原因就是算法不能操作容器本身， 算法能操作的只有迭代器， 也就是说算法能依靠的就是迭代器和容器中的元素类型支持的操作， 所以算法是不能修改容器的大小的

**批改结果：** ⭐⭐⭐ (3/5)

**详细分析：**
- ✅ **概念理解：** 正确抓住了根本原因——算法通过迭代器间接操作，而非直接访问容器
- ✅ **逻辑方向：** 推理链条基本正确：迭代器限制 → 无法调用容器成员函数 → 不能修改大小
- ⚠️ **深度不足：** 停留在"是什么"，未解释 **"为什么这样设计"** （泛型编程、职责分离等核心哲学）
- ⚠️ **完整性欠缺：** 未对比**容器成员函数**（如`push_back`）与**算法**的本质区别
- ⚠️ **表达精炼度：** 语句重复（"不能操作容器本身"与"是不能修改容器的"意思重叠），可更简洁

**完整答案：**
```cpp
// 核心原因：算法与容器的松耦合设计
// 1. 职责分离原则：算法只关心通过迭代器访问/修改元素，不关心容器管理
// 2. 泛型编程需求：算法要适用于所有容器，而不仅限于支持扩容的容器
// 3. 间接控制：真正改变大小的是容器的成员函数（push_back/insert等），算法无法直接调用

// 示例：back_inserter为何不违背原则
copy(src.begin(), src.end(), back_inserter(vec));
// 算法copy仍然只操作迭代器，扩容的是back_inserter在赋值时调用的vec.push_back()
// 改变大小的始终是容器自己的成员函数，算法只是"触发"而非"执行"
```
