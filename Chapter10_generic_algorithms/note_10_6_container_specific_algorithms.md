# 📘 10.6. 容器特定算法 (Container-Specific Algorithms)

> 来源说明：《C++ Primer》 10.6 | 本节涵盖：`list`和`forward_list`容器独有的成员函数算法，它们相比通用算法有性能优势和不同的行为。

---

## 🧠 核心概念总览（严格按原文顺序）

* [*知识点1: 容器特定算法概述*](#id1)
* [*知识点2: list/forward_list的成员算法及其优势*](#id2)
* [*知识点3: Table 10.6 - list和forward_list的成员算法*](#id3)
* [*知识点4: 最佳实践*](#id4)
* [*知识点5: splice成员算法介绍*](#id5)
* [*知识点6: Table 10.7 - splice成员函数的参数*](#id6)
* [*知识点7: 列表特定操作会改变容器*](#id7)

---

<a id="id1"></a>
## ✅ 知识点1: 容器特定算法概述

**理论**
* `list`和`forward_list`除了可以使用通用算法外，还**将几种特定的算法定义为自己独有的成员函数**。这是它们与其他容器的关键区别。

---

<a id="id2"></a>
## ✅ 知识点2: `list`/`forward_list`的成员算法及其优势

**理论**
* **成员算法的必要性**：
    1.  **兼容性（针对sort）**：通用`std::sort`算法要求**随机访问迭代器**，但`list`（双向迭代器）和`forward_list`（前向迭代器）无法满足，因此**必须使用它们自己的`sort`成员函数**。
    2.  **性能（针对其他算法）**：
    * 对于`merge`、`remove`等操作，通用算法通过**交换元素值**实现，对链表效率低
    * 链表专用的成员算法则通过<b>修改节点间的链接(links)</b>来操作，无需移动数据，**性能远优于通用版本**

**注意点**
* ⚠️ **关键限制**：**绝不能对`list`或`forward_list`使用通用`std::sort`算法**。


---

<a id="id3"></a>
## ✅ 知识点3: Table 10.6 - `list`和`forward_list`的成员算法

**理论**
* 下表列出了`list`和`forward_list`定义的成员算法。这些操作**返回void**。
* 其他能接受合适迭代器的通用算法在链表上效率与其他容器相当。

| 操作 | 描述 |
| :--- | :--- |
| `lst.merge(lst2)`<br>`lst.merge(lst2, comp)` | 将已排序的`lst2`合并入已排序的`lst`。**操作后`lst2`为空**。第一版用`<`，第二版用比较操作`comp`。 |
| `lst.remove(val)`<br>`lst.remove_if(pred)` | **删除**所有等于`val`或使谓词`pred`为真的元素。 |
| `lst.reverse()` | **反转**链表元素的顺序。 |
| `lst.sort()`<br>`lst.sort(comp)` | 对链表元素进行**排序**。 |
| `lst.unique()`<br>`lst.unique(binary_pred)` | **删除**连续重复的元素（去重）。 |

**注意点**
* ⚠️ **破坏性操作**：`merge`操作会**清空源链表`lst2`**。
* 💡 **性能核心**：这些成员函数的高性能均源于**直接操作链表指针**。

---

<a id="id4"></a>
## ✅ 知识点4: 最佳实践

**理论**
* 对于`list`和`forward_list`，**应优先使用其成员函数版本的算法，而非标准库中的通用算法**，这是为了获得最佳性能。

**注意点**
* ⚠️ **明确建议**：这是一个重要的性能优化准则。

---

<a id="id5"></a>
## ✅ 知识点5: splice成员算法介绍

**理论**
* `splice`（拼接）是链表数据结构**独有**的算法。它能将节点从一个链表直接“剪切”并“粘贴”到另一个链表，**只修改指针，不涉及任何数据的拷贝或移动**。正因如此，标准库没有提供它的通用版本。



---

<a id="id6"></a>
## ✅ 知识点6: Table 10.7 - splice成员函数的参数

**理论**
* `splice`操作非常灵活，允许移动整个链表、单个元素或一个元素范围。其核心是**将被移动的元素从源链表中移除**。

**表10.7 list和forward_list的splice成员参数**
`lst.splice(args)` 或 `flst.splice_after(args)`

| 参数 | 含义 |
| :--- | :--- |
| `(p, lst2)` | 将`lst2`的**全部元素**移动到当前链表的`p`位置之前（对`forward_list`是`p`之后）。`lst2`**不能是当前链表自身**。 |
| `(p, lst2, p2)` | 将`lst2`中`p2`指向的**单个元素**移动过来。`lst2`**可以是**当前链表自身。 |
| `(p, lst2, b, e)` | 将`lst2`中`[b, e)`范围的**元素**移动过来。`lst2`**可以是**当前链表自身，但`p`**不能指向该范围内的元素**。 |

**注意点**
* 💡 **参数形式**：三种形式分别对应：移动整个链表、移动单个元素、移动一个范围。
* ⚠️ **关键限制**：`(p, lst2)`形式中，`lst2`与当前链表不能是同一个对象。

---

<a id="id7"></a>
## ✅ 知识点7: 列表特定操作会改变容器

**理论**
* **列表成员算法与通用算法的本质区别**：列表的成员算法**会直接修改容器本身**，而许多同名的通用算法只操作迭代器范围，不改变底层容器。
    * **`remove`和`unique`**：列表版本直接**删除元素**。通用版本（如`std::remove`）通常只是重新排列元素，需要额外调用`erase`。
    * **`merge`和`splice`**：列表版本是**破坏性的**。例如，列表的`merge`会**清空参数链表**，将所有节点并入当前链表；而通用`std::merge`则保持输入序列不变。

**注意点**
* ⚠️ **核心区别**：必须牢记**列表的成员算法（`merge`, `splice`, `remove`, `unique`）会直接改变容器内容**，行为与通用算法不同。
* 🔄 **设计关联**：这一特性与链表“插入/删除不使其他迭代器失效”（仅通过修改链接实现）的特性完全一致。

---

## 🔑 核心要点总结
1.  **专用成员**：`list`和`forward_list`拥有专属的`sort`, `merge`, `remove`, `reverse`, `unique`和`splice`成员函数算法。
2.  **存在原因**：1) `sort`因迭代器限制必须用成员版；2) 其他操作为了**高性能**（改链接 vs 换数据）。
3.  **使用准则**：**优先使用链表的成员算法**而非通用算法（最佳实践）。
4.  **行为差异**：列表成员算法**直接修改容器**（如`merge`清空源链表），这与通用算法行为不同。
5.  **链表特技**：`splice`是仅通过修改指针实现的高效节点移动操作。

## 📌 考试速记版
*   **成员算法列表**：`sort`, `merge`, `remove`, `reverse`, `unique`, `splice`。
*   **为什么用成员版**：`sort`不能用通用的（迭代器不行），其他用成员版**更快**（改指针）。
*   **关键区别点**：列表的`merge`**会清空参数链表**；列表的`remove`**直接删元素**（通用版不直接删）。
*   **首要准则**：对链表，**永远优先考虑成员函数算法**。
*   **splice三形式**：
    *   `(p, lst2)`: 全搬，`lst2`≠自己。
    *   `(p, lst2, p2)`: 搬一个，`lst2`可=自己。
    *   `(p, lst2, b, e)`: 搬范围，`lst2`可=自己，但`p`不在范围内。

**记忆口诀**：
链表算法有专精，排序合并删独反。
通用排序不可用，迭代权限是根源。
改链性能胜交换，成员版本应优先。
合并拼接破坏强，源容元素被掏光。