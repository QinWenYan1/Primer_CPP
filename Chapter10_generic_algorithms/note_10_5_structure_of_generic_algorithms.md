# 📘 10.5 通用算法的结构 (Structure of Generic Algorithms)

> 来源说明：C++ Primer 10.5 | 本节涵盖：迭代器类别、算法参数模式及命名约定

---

## 🧠 核心概念总览（严格按原文顺序）

* [*知识点1: 迭代器类别*](#id1)：算法对迭代器操作要求的五种分类
* [*知识点2: 输入迭代器*](#id2)：只读、单遍扫描的迭代器
* [*知识点3: 输出迭代器*](#id3)：只写、单遍扫描的迭代器
* [*知识点4: 前向迭代器*](#id4)：可读写、多遍扫描的迭代器
* [*知识点5: 双向迭代器*](#id5)：支持双向移动的迭代器
* [*知识点6: 随机访问迭代器*](#id6)：支持常数时间任意访问的迭代器
* [*知识点7: 算法参数模式*](#id7)：算法的四种常见参数形式
* [*知识点8: 算法命名约定*](#id8)：通过重载、后缀等方式区分算法变体

---

<a id="id1"></a>
## ✅ 知识点1: 迭代器类别

**理论**
* 任何算法最根本的特性是它要求其迭代器提供的操作列表。
* 有些算法，如 `find`，只需要通过迭代器访问元素、递增迭代器以及比较两个迭代器是否相等的能力。
* 其他算法，如 `sort`，则需要读取、写入和随机访问元素的能力。
* 算法要求的迭代器操作被分为**迭代器类别**。
* 每个算法都为其每个迭代器参数指定必须提供哪种迭代器。

**教材示例代码**
```
// 无
```

**注意点**
* ⚠️ 标准库为每个泛型算法和数值算法的每个迭代器参数指定了最低类别要求。
* ⚠️ 对于每个参数，迭代器的能力必须至少与规定的最低要求一样强。传递能力较弱的迭代器是一个错误。
* 💡 许多编译器在我们向算法传递错误类别的迭代器时不会报错。

---

<a id="id2"></a>
## ✅ 知识点2: 输入迭代器

**理论**
* **输入迭代器**：可以读取序列中的元素。输入迭代器必须提供：
  * 相等和不等运算符 (`==`, `!=`) 来比较两个迭代器。
  * 前缀和后缀递增 (`++`) 来推进迭代器。
  * 解引用运算符 (`*`) 来读取元素；解引用可能只出现在赋值语句的右侧。
  * 箭头运算符 (`->`) 作为 `(*it).member` 的同义词——即解引用迭代器并从底层对象获取成员。
* 输入迭代器只能顺序使用。我们保证 `*it++` 是有效的，但递增输入迭代器可能使指向该流的所有其他迭代器失效。
* 因此，不能保证可以保存输入迭代器的状态并通过该保存的迭代器检查元素。
* 因此，输入迭代器只能用于单遍扫描算法。
* `find` 和 `accumulate` 算法需要输入迭代器；`istream_iterator` 是输入迭代器。

**教材示例代码**
```
// 无
```

**注意点**
* 🔄 输入迭代器是五种类别中能力最弱的一种（除输出迭代器外）。

---

<a id="id3"></a>
## ✅ 知识点3: 输出迭代器

**理论**
* **输出迭代器**：可以看作与输入迭代器功能互补；它们写入元素而不是读取元素。输出迭代器必须提供：
  * 前缀和后缀递增 (`++`) 来推进迭代器。
  * 解引用 (`*`)，它只能作为赋值的左侧出现（给解引用的输出迭代器赋值会写入底层元素）。
* 只能给输出迭代器的给定值赋值一次。
* 像输入迭代器一样，输出迭代器只能用于单遍扫描算法。
* 用作目的位置的迭代器通常是输出迭代器。例如，`copy` 的第三个参数是输出迭代器。`ostream_iterator` 类型是输出迭代器。

**教材示例代码**
```
// 无
```

**注意点**
* ⚠️ 输出迭代器通常用于表示算法的输出目标。

---

<a id="id4"></a>
## ✅ 知识点4: 前向迭代器

**理论**
* **前向迭代器**：可以读取和写入给定的序列。它们只能沿一个方向在序列中移动。
* 前向迭代器支持输入迭代器和输出迭代器的所有操作。此外，它们可以多次读取或写入同一元素。
* 因此，我们可以使用前向迭代器的保存状态。因此，使用前向迭代器的算法可以对序列进行多遍扫描。
* `replace` 算法需要前向迭代器；`forward_list` 上的迭代器是前向迭代器。

**教材示例代码**
```
// 无
```

**注意点**
* 🔄 前向迭代器支持多遍扫描算法，这是它与输入/输出迭代器的关键区别。

---

<a id="id5"></a>
## ✅ 知识点5: 双向迭代器

**理论**
* **双向迭代器**：可以正向或反向读取和写入序列。除了支持前向迭代器的所有操作外，双向迭代器还支持前缀和后缀递减 (`--`) 运算符。
* `reverse` 算法需要双向迭代器，并且除了 `forward_list` 之外，标准库容器提供的迭代器都满足双向迭代器的要求。

**教材示例代码**
```
// 无
```

**注意点**
* 💡 大多数标准库容器的迭代器（如 `list`, `vector`, `deque` 等）都是双向迭代器或更强。

---

<a id="id6"></a>
## ✅ 知识点6: 随机访问迭代器

**理论**
* **随机访问迭代器**：提供对序列中任意位置的常数时间访问。这些迭代器支持双向迭代器的所有功能。此外，随机访问迭代器支持关系运算符（`<`, `<=`, `>`, `>=`）来比较两个迭代器的相对位置。
* 支持在迭代器和整数值上进行加法和减法运算符（`+`, `+=`, `-`, `-=`）。结果是在序列中前进（或后退）整数个元素的迭代器。
* 应用于两个迭代器的减法运算符 (`-`)，产生两个迭代器之间的距离。
* 下标运算符 (`iter[n]`) 作为 `*(iter + n)` 的同义词。
* `sort` 算法需要随机访问迭代器。`array`、`deque`、`string` 和 `vector` 的迭代器是随机访问迭代器，用于访问内置数组元素的指针也是随机访问迭代器。

**教材示例代码**
```
// 无
```

**注意点**
* ⚠️ `sort` 算法要求随机访问迭代器，因此不能直接用于 `list` 或 `forward_list`。

---

<a id="id7"></a>
## ✅ 知识点7: 算法参数模式

**理论**
* 大多数算法具有以下四种形式之一：
```
alg(beg, end, other args);
alg(beg, end, dest, other args);
alg(beg, end, beg2, other args);
alg(beg, end, beg2, end2, other args);
```
* 其中 `alg` 是算法的名称，`beg` 和 `end` 表示算法操作的输入范围。
* `dest` 参数是一个迭代器，表示算法可以写入其输出的目标位置。算法假定写入所需数量的元素是安全的。
* 如果 `dest` 是直接引用容器的迭代器，则算法将其输出写入容器内的现有元素。更常见的是，`dest` 绑定到插入迭代器或 `ostream_iterator`。
* 接受单独 `beg2` 或同时接受 `beg2` 和 `end2` 的算法使用这些迭代器表示第二个输入范围。这些算法通常使用来自第二范围的元素与输入范围结合来执行计算。
* 当算法同时接受 `beg2` 和 `end2` 时，这些迭代器表示第二个范围。此类算法接受两个完全指定的范围：由 `[beg, end]` 表示的输入范围，以及由 `[beg2, end2]` 表示的第二个输入范围。
* 仅接受 `beg2`（而不接受 `end2`）的算法将 `beg2` 视为第二个输入范围中的第一个元素。此范围的末尾未指定。相反，这些算法假定从 `beg2` 开始的范围至少与 `beg, end` 表示的范围一样大。

**教材示例代码**
```
// 无具体代码，为参数模式描述
```

**注意点**
* ⚠️ 写入输出迭代器的算法假定目标足够大以容纳输出。
* ⚠️ 接受单独 `beg2` 的算法假定从 `beg2` 开始的序列与 `beg` 和 `end` 表示的范围一样大。

---

<a id="id8"></a>
## ✅ 知识点8: 算法命名约定

**理论**
* **使用重载传递谓词**：使用谓词替代 `<` 或 `==` 运算符且不接受其他参数的算法通常是重载的。函数的一个版本使用元素类型的运算符比较元素；第二个版本接受一个额外的参数，该参数是一个用于替代 `<` 或 `==` 的谓词。
```
unique(beg, end); // 使用 == 运算符比较元素
unique(beg, end, comp); // 使用 comp 比较元素
```
* **带 _if 后缀的版本**：接受元素值的算法通常有第二个命名（非重载）版本，该版本接受一个谓词来代替值。接受谓词的算法带有后缀 `_if`。
```
find(beg, end, val); // 在输入范围内查找 val 的第一个实例
find_if(beg, end, pred); // 查找第一个使 pred 为真的实例
```
* **区分复制与非复制版本**：默认情况下，重排元素的算法将重排后的元素写回给定的输入范围。这些算法提供了第二个版本，该版本写入指定的输出目标。写入目标的算法在其名称后附加 `_copy`。
```
reverse(beg, end); // 反转输入范围内的元素
reverse_copy(beg, end, dest); // 以逆序将元素复制到 dest
```
* 有些算法同时提供 `_copy` 和 `_if` 版本。这些版本接受一个目标迭代器和一个谓词。
```
// 从 v1 中移除奇数元素
remove_if(v1.begin(), v1.end(),
          [](int i) { return i % 2; });
// 只将 v1 的偶数元素复制到 v2；v1 不变
remove_copy_if(v1.begin(), v1.end(), back_inserter(v2),
               [](int i) { return i % 2; });
```

**教材示例代码**
```cpp
// remove_if(v1.begin(), v1.end(),
//           [](int i) { return i % 2; });
// remove_copy_if(v1.begin(), v1.end(), back_inserter(v2),
//                [](int i) { return i % 2; });
```

**注意点**
* 💡 提供命名版本（如 `find_if`）而不是重载版本，是因为两个版本的算法接受相同数量的参数，可能导致重载歧义。
* 🔄 `_copy` 版本允许在不修改原序列的情况下获得结果。

---

## 🔑 核心要点总结
1.  **迭代器类别是算法的基础**：算法通过要求特定类别的迭代器来定义其操作能力，从最弱的输入/输出迭代器到最强的随机访问迭代器。
2.  **类别构成层次结构**：除了输出迭代器，较高类别的迭代器提供较低类别迭代器的所有操作。
3.  **算法参数模式化**：大多数算法遵循几种固定的参数模式，如单一目标、第二输入序列等，理解这些模式有助于学习新算法。
4.  **命名约定清晰**：通过重载、`_if` 后缀和 `_copy` 后缀，标准库提供了清晰的方式来区分算法的不同变体（使用谓词、是否复制输出等）。

## 📌 考试速记版
* **五类迭代器**：输入(只读单遍)、输出(只写单遍)、前向(读写多遍)、双向(加减)、随机访问(全算术)。
* **关键算法要求**：`find`需输入；`replace`需前向；`reverse`需双向；`sort`需随机访问。
* **参数模式**：`alg(beg, end, ...)`；目标(`dest`)；第二序列(`beg2`, `end2`)。
* **命名后缀**：`_if` 用谓词替代值；`_copy` 输出到目标，不修改原序列。
* **重要警告**：写`dest`的算法假定空间足够；单`beg2`的算法假定第二序列足够大。

**口诀**：迭代器，分五类，能力递进有层次。算法模式记四种，命名后缀辨功能。