# **C++ 动态内存管理 | 章节知识表**

>根据《C++ Primer》动态内存章节内容，按照指南要求整理的核心知识表如下：

| 类别 | 概念 | 定义 | 关键点 |
| :--- | :--- | :--- | :--- |
| **🔧 内存管理基础** | **new** | 从**自由空间（堆）**分配内存的表达式。 | • 分配单个对象：`new T` <br>• 分配数组：`new T[n]` <br>• 默认**默认初始化**，可提供初始化器 |
| | **delete** | 释放由`new`分配的内存。 | • 释放单个对象：`delete p` <br>• 释放数组：`delete [] p` <br>• `p`可以为空或必须指向`new`分配的内存 |
| | **自由空间 (Free Store) / 堆 (Heap)** | 程序用于保存**动态分配对象**的内存池。 | • 动态分配的对象在其中生存，直到被显式删除或程序终止。 |
| | **动态分配对象 (Dynamically Allocated Object)** | 在自由空间上分配的对象。 | • 生命周期由其分配方式控制，而非作用域。 |
| **🛡️ 智能指针核心** | **智能指针 (Smart Pointer)** | 行为类似指针，但能自动管理所指向内存生命周期的库类型。 | • 核心目的：**自动释放内存**，避免内存泄漏和悬垂指针。 <br>• 现代C++程序应优先使用。 |
| | **shared_ptr** | 提供**共享所有权**的智能指针。 | • **引用计数**跟踪有多少`shared_ptr`指向同一对象。 <br>• 当最后一个指向对象的`shared_ptr`被销毁时，对象被自动删除。 |
| | **unique_ptr** | 提供**独占所有权**的智能指针。 | • 同一时间只能有一个`unique_ptr`指向特定对象。 <br>• **不能直接拷贝或赋值**（可通过`move`转移所有权）。 <br>• 指向对象销毁时，`unique_ptr`自动删除它。 |
| | **weak_ptr** | 指向由`shared_ptr`管理的对象的**弱引用**智能指针。 | • **不控制对象生命周期**，不增加引用计数。 <br>• 用于解决`shared_ptr`可能产生的循环引用问题。 |
| | **引用计数 (Reference Count)** | 追踪共享同一对象的用户数量的计数器。 | • `shared_ptr`使用它来决定何时可以安全删除内存。 |
| | **删除器 (Deleter)** | 传递给智能指针的函数，用于替代`delete`来销毁其绑定的对象。 | • 允许自定义对象释放逻辑（如关闭文件、释放特定资源）。 |
| **⚙️ 相关机制与概念** | **allocator** | 一个库类，用于分配**未构造的原始内存块**。 | • 提供比`new/delete`更底层、更灵活的内存控制，常与容器和算法配合使用。 |
| | **悬垂指针 (Dangling Pointer)** | 指向曾经存在对象但该对象已被释放的内存的指针。 | • 使用悬垂指针是严重的程序错误，且** notoriously difficult to debug**。 |
| | **析构函数 (Destructor)** | 当对象离开作用域或被`delete`时，用于清理对象的特殊成员函数。 | • 智能指针在释放内存时会调用其所管理对象的析构函数。 |
| | **placement new** | 一种接受额外参数的`new`形式。 | • 例如：`new (nothrow) int`，指示`new`在分配失败时不抛出异常。 |

---
### **使用说明**
1.  **快速自查**：按类别查找相关概念及其精确定义。
2.  **对比记忆**：对比`new/delete`与`allocator`、三种智能指针之间的核心差异。
3.  **要点复习**：关注“关键点”列，快速回顾每个概念的核心特性和注意事项。

**来源章节**：C++ 动态内存管理基础（涵盖原始内存操作与智能指针）。