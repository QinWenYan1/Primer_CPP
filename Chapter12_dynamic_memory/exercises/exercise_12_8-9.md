## 📊 练习批改与分析

### Exercise 12.8 函数错误分析

**原题：** Explain what if anything is wrong with the following function.
```cpp
bool b() {
    int* p = new int;
    // ...
    return p;
}
```

**你的答案：**
```
函数申明与返回的对象类型无法匹配并且无法转换
```

**批改：** ⭐⭐⭐ 3/5 部分正确，但不够全面

**详细分析：**
- ⚠️ **类型转换问题理解不准确**：指针到bool的转换实际上是有效的
- ❌ **遗漏了主要问题**：没有提到内存泄漏这个核心问题
- ✅ **意识到了类型不匹配**：知道返回类型有问题

**正确答案：**

该函数存在两个主要问题：

### ❌ 问题 1：**返回类型不匹配**

```cpp
bool b() { ... return p; }
```

* `p` 是 `int*`
* 函数返回类型是 `bool`

发生了什么？

```cpp
return p;  // 指针 → bool
```

这会被隐式转换为：

* `p != nullptr` → `true`
* 或 `false`

👉 **指针的值被丢弃了**

---

### ❌ 问题 2（致命）：**指针丢失，内存无法释放**

执行流程是：

1. `new int` 在堆上分配了一块内存
2. `p` 指向这块内存
3. `return p;`

   * 只返回了一个 `bool`
   * **没有任何地方保存这个指针**
4. 函数结束，`p` 是局部变量，被销毁
5. **堆上的那块 `int` 再也无法访问**

👉 **内存泄漏成立**



因为它同时满足泄漏的两个条件：

1. **动态分配了内存**
2. **所有指向该内存的指针都丢失了**

这正是内存泄漏的定义。

---

### Exercise 12.9 代码行为分析

**原题：** Explain what happens in the following code:
```cpp
int *q = new int(42), *r = new int(100);
r = q;
auto q2 = make_shared<int>(42), r2 = make_shared<int>(100);
r2 = q2;
```

**你的答案：**
```
首先程序初始化了两个内置指针，分别是q, r, 然后接下来程序让r也指向了q。
这个时候程序并没有里吗释放没有使用的内存，也就是之前r指向的，这个时候就会发生内存泄漏，程序崩溃
接下来程序又初始化了两个shared_ptr, 并且将r2也同时指向q2的shared_ptr,那么r2的counter就降低为0，而q2提高到了2, r2这个时候自动被删除，内存也自动被释放
直到整个程序结束, r2, q2两个local variable也被销毁，这个时候没有任何variable指向q2，此时的counter也变为0,同样被销毁
```

**批改：** ⭐⭐⭐⭐ 4/5 优秀答案！但有一些小错误

**详细分析：**
- ✅ **原始指针部分分析正确**：准确指出了内存泄漏
- ⚠️ **表述有误**：内存泄漏不会导致"程序崩溃"，只是资源泄露
- ✅ **智能指针部分基本正确**：理解了引用计数的变化
- ⚠️ **细节有误**：`q2`和`r2`是局部变量，离开作用域时引用计数减少，但描述不够准确

**正确答案：**

### 原始指针部分：
```cpp
int *q = new int(42), *r = new int(100);
r = q;
```
1. 第1行：动态分配两个`int`对象
   - `q`指向值为42的`int`
   - `r`指向值为100的`int`
2. 第2行：`r = q;`
   - `r`现在指向`q`所指向的对象（值为42）
   - 原来`r`指向的值为100的对象现在没有指针指向它
   - **内存泄漏**：无法再访问或释放值为100的`int`对象

---