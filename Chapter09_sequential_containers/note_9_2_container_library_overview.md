# 📘 9.2 Container Library Overview (容器库概述)

> 来源说明：C++ Primer 9.2 | 本节涵盖：C++标准容器库的通用操作和基本概念

---

## 🗺️ 知识体系图

```mermaid
graph TD
    A[容器库概述] --> B[通用容器操作]
    A --> C[迭代器系统]
    A --> D[容器初始化]
    A --> E[赋值与swap]
    A --> F[大小操作]
    A --> G[关系运算符]
    
    B --> B1[类型别名]
    B --> B2[构造函数]
    B --> B3[赋值操作]
    
    C --> C1[迭代器范围]
    C --> C2[左包含区间]
    C --> C3[begin/end成员]
    
    D --> D1[拷贝初始化]
    D --> D2[列表初始化]
    D --> D3[大小相关构造]
    
    E --> E1[assign操作]
    E --> E2[swap优化]
```

## 🧠 核心概念总览

* [*知识点1: 容器操作层次结构*](#id1)：容器操作的分层体系
* [*知识点2: 通用容器操作*](#id2)：所有容器类型共有的操作
  * [*知识点2.1: 容器的定义与初始化*](#id6)：容器的定义与初始化
* [*知识点3: 迭代器系统*](#id7)：容器的迭代器机制
  * [*知识点3.1: 迭代器范围*](#id8)：迭代器范围的概念和性质
  * [*知识点3.2: 左包含区间*](#id9)：左包含区间的特性和编程意义
  * [*知识点3.3: begin和end成员*](#id10)：获取迭代器的成员函数
* [*知识点4: 容器类型成员*](#id11)：容器内部定义的类型
* [*知识点5: 容器定义和初始化*](#id12)：容器的各种初始化方式
  * [*知识点5.1: 拷贝初始化*](#id13)：通过拷贝另一个容器初始化
  * [*知识点5.2: 列表初始化(C++11)*](#id14)：使用初始化列表
  * [*知识点5.3: 大小相关构造函数*](#id15)：指定大小的构造方式
  * [*知识点5.4: 固定大小数组*](#id16)：array容器的特殊性质
* [*知识点6: 赋值和swap操作*](#id17)：容器内容的修改
  * [*知识点6.1: assign操作*](#id18)：顺序容器的assign成员
  * [*知识点6.2: swap操作*](#id19)：容器内容的快速交换
* [*知识点7: 容器大小操作*](#id20)：获取容器大小的函数
* [*知识点8: 关系运算符*](#id21)：容器之间的比较操作

---

<a id="id1"></a>
## ✅ 知识点1: 容器操作层次结构

**理论**
* 容器类型的操作形成一个层次结构：
  - 某些操作由所有容器类型提供
  - 其他操作特定于顺序容器、关联容器或无序容器
  - 还有一些操作只对较小的容器子集通用

**注意点**
* 🎯 理解操作的分层有助于记忆不同容器的能力
* 🔄 关联容器和无序容器的特定操作在第11章详细讨论

---

<a id="id2"></a>
## ✅ 知识点2: 通用容器操作

**理论**
* 以下列出了所有容器类型都支持的操作
* 这些操作构成了容器的基础接口


#### 📊 容器操作

#### 类型别名 (Type Aliases)

| 别名 | 描述 |
| :--- | :--- |
| `iterator` | 此容器类型的迭代器类型 |
| `const_iterator` | 可以读取但不能更改其元素的迭代器类型 |
| `size_type` | 无符号整型，足够大以容纳此容器类型可能容纳的最大容器大小 |
| `difference_type` | 有符号整型，足够大以容纳两个迭代器之间的距离 |
| `value_type` | 元素类型 |
| `reference` | 元素的 **左值类型 (lvalue type)**；是 `value_type&` 的同义词 |
| `const_reference` | 元素的 **const 左值类型** (即 `const value_type&`) |

---

#### 构造 (Construction)

| 操作 | 描述 |
| :--- | :--- |
| `C c;` | 默认构造函数，空容器 (数组: 参见 p. 336) |
| `C c1(c2);` | 将 `c2` 复制构造为 `c1` |
| `C c(b, e);` | 从由迭代器 `b` 和 `e` 指定的范围复制元素；(**不适用于 array**) |
| `C c{a,b,c...};` | 列表初始化 `c` |

---

#### 赋值与交换 (Assignment and swap)

| 操作 | 描述 |
| :--- | :--- |
| `c1 = c2` | 用 `c2` 中的元素替换 `c1` 中的元素 |
| `c1 = {a,b,c...}` | 用列表中的元素替换 `c1` 中的元素 (**不适用于 array**) |
| `a.swap(b)` | 交换 `a` 和 `b` 中的元素 |
| `swap(a, b)` | 等同于 `a.swap(b)` |

---

#### 大小 (Size)

| 操作 | 描述 |
| :--- | :--- |
| `c.size()` | `c` 中的元素数量 (**不适用于 forward_list**) |
| `c.max_size()` | `c` 可以容纳的最大元素数量 |
| `c.empty()` | 如果 `c` 包含任何元素则为 `false`，否则为 `true` |

---

#### 添加/删除元素 (**不适用于 `array`**)

> *注意：这些操作的接口因容器类型而异*

| 操作 | 描述 |
| :--- | :--- |
| `c.insert(args)` | 将 `args` 指定的元素复制到 `c` 中 |
| `c.emplace(inits)` | 使用 `inits` 在 `c` 中构造一个元素 |
| `c.erase(args)` | 删除由 `args`迭代器指定的元素 |
| `c.clear()` | 从 `c` 中移除所有元素；返回 `void` |

---

#### 相等性与关系运算符 (Equality and Relational Operators)

| 运算符 | 描述 |
| :--- | :--- |
| `==`, `!=` | 相等性适用于所有容器类型 |
| `<`, `<=`, `>`, `>=` | 关系运算 (**不适用于无序关联容器 (unordered associative containers)**) |

---

#### 获取迭代器 (Obtain Iterators)

| 操作 | 描述 |
| :--- | :--- |
| `c.begin()`, `c.end()` | 返回指向第一个元素、**尾后**元素的迭代器 |
| `c.cbegin()`, `c.cend()` | 返回 `const_iterator` |

---

#### 可逆容器的附加成员 (**不适用于 `forward_list`**)

| 成员 | 描述 |
| :--- | :--- |
| `reverse_iterator` | 以相反顺序访问元素的迭代器 |
| `const_reverse_iterator` | 不能写入元素的 **反向** 迭代器 |
| `c.rbegin()`, `c.rend()` | 返回指向最后一个元素、**首前** 元素的迭代器 |
| `c.crbegin()`, `c.crend()` | 返回 `const_reverse_iterator` |

---

#### 定义和初始化容器 (Defining and Initializing Containers)

> 通用构造函数和初始化方式

| 语法/操作 | 描述 |
| :--- | :--- |
| `C c;` | **默认构造函数**。如果 `C` 是 `array`，则 `c` 中的元素是 **默认初始化** 的；否则 `c` 是空的。 |
| `C c1(c2)` | `c1` 是 `c2` 的拷贝。`c1` 和 `c2` 必须具有相同的类型（即必须是相同的容器类型并存储相同的元素类型；对于 `array`，还必须具有相同的大小）。 |
| `C c1 = c2` | 与 `C c1(c2)` 相同。 |
| `C c{a, b, c...}` | `c` 是初始化列表中的元素的拷贝。列表中的元素类型必须与 `C` 的元素类型兼容。对于 `array`，列表必须与数组大小具有相同或更少的元素；任何缺失的元素都将进行 **值初始化** (§ 3.3.1, p. 98)。 |
| `C c = {a, b, c...}` | 与 `C c{a, b, c...}` 相同。 |
| `C c(b, e)` | `c` 是由迭代器 `b` 和 `e` 指定的范围内的元素的拷贝。范围内的元素类型必须与 `c` 的元素类型兼容。(**不适用于 array**。) |

---

#### 仅适用于顺序容器 (Sequential Containers) 的构造函数

> 仅对顺序容器（不包括 `array`）有效。

| 语法/操作 | 描述 |
| :--- | :--- |
| `C seq(n)` | `seq` 拥有 $n$ 个 **值初始化** 的元素；此构造函数是 **explicit** (§ 7.5.4, p. 296)。(**不适用于 string**。) |
| `C seq(n, t)` | `seq` 拥有 $n$ 个值为 $t$ 的元素。 |

**注意点**
* ⚠️ 由于`array`是 定长、内嵌元素 的聚合类型，没有构造函数，其默认构造函数不会创建空容器
* ⚠️ `swap`操作通常比复制元素快得多
* ⚠️ `empty()`通常比检查`size() == 0`更高效 
  * `empty()` 只需看容器内部一个布尔标志，而 `size()` 可能要遍历或做减法运算。

---
<a id="id6"></a>
## ✅ 知识点2.1: 容器的定义与初始化

* 一般来说，每个容器都定义在一个与其类型名称相同的头文件中。例如：
    * `deque` 在 `<deque>` 头文件中。
    * `list` 在 `<list>` 头文件中。
* 容器是 **类模板 (class templates)**。

* 与 `vector` 一样，我们必须提供附加信息来生成特定的容器类型。
* 对于大多数（但不是全部）容器，我们必须提供的信息是 **元素类型 (element type)**：
    * `list<Sales_data>`: 列表持有 `Sales_data` 类型的对象。
    * `deque<double>`: 双端队列持有 `double` 类型的值。

---
<a id="id5"></a>
## ✅ 知识点2.2: 容器可以容纳的类型约束

**理论**
* **任何类型皆可作为元素类型：** 几乎任何类型都可以用作顺序容器的元素类型。
  * **容器的容器：** 可以定义一个容器，其元素类型本身就是另一个容器类型。
* 尽管容器几乎可以存储任何类型，但**某些容器操作**会对其所存储的**元素类型**施加额外的要求或约束。
* 如果一个容器的元素类型不满足某个操作的要求，则**不能**对该容器执行该操作。

  * **问题所在：** 接受大小参数的顺序容器构造函数 (§ 3.3.1) 会使用元素类型的**默认构造函数**来初始化元素。
  * **后果：** 如果一个类**没有默认构造函数** (`noDefault` 类)，那么您就**不能仅凭**元素数量来构造该容器。

**代码示例**
```cpp
  vector<vector<string>> lines;   //正确： lines 是一个元素为 string 向量的向量
  vector<noDefault> v1(10, init); //正确
  vector<noDefault> v1(10);       //错误：必须提供元素初始化式
```


**注意点**
* ⚠️ 较旧的编译器可能需要在右侧的连续尖括号之间留出空格，例如 `vector<vector<string> >`


---

<a id="id7"></a>
## ✅ 知识点3: 迭代器系统

**理论**
* **迭代器具有通用接口**：如果迭代器提供某个操作，那么每个提供该操作的迭代器都以相同的方式支持它
* 所有标准容器类型的迭代器**都允许**我们访问容器中的元素，都提供**解引用运算符**
* 所有库容器的迭代器**都定义递增运算符**来移动到下一个元素

**注意点**
* ⚠️ `forward_list`迭代器**不支持**递减(`--`)运算符
* 🔄 迭代器**算术运算**（3.7章的表）仅适于<b>`string`、`vector`、`deque`和`array`的迭代器</b>

---

<a id="id8"></a>
## ✅ 知识点3.1: 迭代器范围

**理论**
迭代器范围由两个迭代器定义：
- `begin` - 指向第一个元素
- `end` - 指向最后一个元素的下一个位置

范围表示为`[begin, end)`，是左包含区间：
- 包含`begin`指向的元素
- 不包含`end`指向的位置

**有效范围要求**
- 两个迭代器必须属于同一容器
- `end`不能位于`begin`之前
- 可以通过重复递增`begin`到达`end`

**注意点**
* ⚠️ 编译器**无法**保证这些需求被满足，我们需要去保证这些这些规则被满足

---

<a id="id9"></a>
### ✅ 知识点3.2: 左包含区间

**理论**
* 元素范围称为**左包含区间**(left-inclusive ranges)
* **左包含区间的便利属性**
  * 如果`begin`等于`end`，范围为空
  * 如果`begin`不等于`end`，范围内至少有一个元素，`begin`引用该范围内的第一个元素
  * 我们可以递增`begin`若干次直到`begin == end`
* 这种设计保证循环能正确处理空范围和非空范围

**教材示例代码**
```cpp
// 处理元素范围的典型循环
while (begin != end) {
    *begin = val;  // 范围非空，begin指向元素
    ++begin;       // 推进迭代器获取下一个元素
}
```
---

<a id="id10"></a>
## ✅ 知识点3.3: `begin`和`end`成员

**理论**
* `begin()`和`end()`操作生成引用容器中第一个和最后一个元素之后位置的迭代器
* 这些迭代器最常用于形成包含容器中所有元素的迭代器范围

**`begin`和`end`的版本**
* 带`r`的版本返回**反向**迭代器
* 以`c`开头的返回相关迭代器**的`const`版本**
* 不带`c`的函数是重载的：一个是`const`成员返回`const_iterator`类型，另一个是非`const`成员返回`iterator`类

**与`begin`，`end`共同使用`auto`**(C++11)
* C++11标准支持将`auto`和`begin`, `end`函数共同使用

**教材示例代码**
```cpp
list<string> a = {"Milton", "Shakespeare", "Austen"};
auto it1 = a.begin();    // list<string>::iterator
auto it2 = a.rbegin();   // list<string>::reverse_iterator  
auto it3 = a.cbegin();   // list<string>::const_iterator
auto it4 = a.crbegin();  // list<string>::const_reverse_iterator

// 类型需要显示
list<string>::iterator it5 = a.begin();
list<string>::const_iterator it6 = a.begin();
// iterator或者const_iterator取决于a类型
auto it7 = a.begin(); // const_iterator只有当a是const
auto it8 = a.cbegin(); // it8是const_iterator

```

**注意点**
* 💡 当**不需要**写访问时，使用`cbegin`和`cend`


---

<a id="id11"></a>
## ✅ 知识点4: 容器类型成员

**理论**
* 除了我们已经使用的类型，大多数容器还提供**反向迭代器**
* 反向迭代器是**向后**遍历容器的迭代器，颠倒了迭代器操作的含义
  * `++`对于反向迭代器来说就是遍历上一个元素
* 元素相关的类型别名如`difference_type`, `const_reference`，让我们可以使用容器中存储的元素类型而无需知道具体类型
  * 如果需要容器中存储的**元素的类型**：我们直接使用`Container name::value_type`即可
  * 如果我们需要**元素类型的引用类型**，直接使用 `Container name::reference`或`Container name::const_reference`
* 这些与元素相关的类型别名在**泛型程序**中最为有用（16章）
**教材示例代码**
```cpp
// iter是list<string>定义的迭代器类型
list<string>::iterator iter;

// count是vector<int>定义的difference_type类型
vector<int>::difference_type count;
```


---

<a id="id12"></a>
## ✅ 知识点5: 容器定义和初始化

**理论**
* 每个容器类型都定义了一个默认构造函数
* 除了`array`，默认构造函数创建指定类型的**空容器**
* 除了`array`，其他构造函数接受**指定容器大小**和**元素初始值**的参数

**注意点**
* ⚠️ `array`的默认构造函数不会创建空容器
* 🔄 容器类型是类模板，**必须**提供额外信息来生成特定的容器类型

---

<a id="id13"></a>
## ✅ 知识点5.1: 拷贝初始化

**理论**
* 创建新容器作为另一个容器的副本有两种方式：
  1. 直接复制容器
      * 要求： 容器类型和元素类型必须匹配（即必须完全相同）
  2. 复制迭代器对表示的元素范围（`array`除外）
      * 要求放松：
        * **容器类型**： 新容器和原始容器的类型**不需要**相同
        * **元素类型**： 新容器和原始容器的元素类型**可以**不同，只要能够将原始容器中的元素转换成新容器的元素类型即可
* 接受两个迭代器的构造函数允许我们复制容器的**子序列**来初始化

**教材示例代码**
```cpp
list<string> authors = {"Milton", "Shakespeare", "Austen"};
vector<const char*> articles = {"a", "an", "the"};

list<string> list2(authors);        // 正确：类型匹配
deque<string> authList(authors);    // 错误：容器类型不匹配
vector<string> words(articles);     // 错误：元素类型必须匹配

// 正确：可以将const char*元素转换为string
forward_list<string> words(articles.begin(), articles.end());
```

**注意点**
* ⚠️ 将容器初始化为另一个容器的副本时，两个容器的容器类型和元素类型**必须**相同


---

<a id="id14"></a>
## ✅ 知识点5.2: 列表初始化(C++11)

**理论**
* 在新标准中，我们可以列表初始化容器
* 对于`array`以外的类型，初始化列表还隐式指定容器的大小

**教材示例代码**
```cpp
list<string> authors = {"Milton", "Shakespeare", "Austen"};
vector<const char*> articles = {"a", "an", "the"};
```

**注意点**
* 🔄 容器将具有与初始化器数量相同的元素

---

<a id="id15"></a>
## ✅ 知识点5.3: 大小相关构造函数

**理论**
* 除了与关联容器共有的构造函数外，还可以提供一下参数初始化顺序容器（不包括`array`）
  1. **大小**
  2. (可选的)**元素初始化器**
* 如果使用者不提供元素初始化器，库会为我们创建一个**值初始化**的元素
*  如果元素类型没有默认构造函数，则**必须**与大小一起指定显式元素初始化器

**教材示例代码**
```cpp
vector<int> ivec(10, -1);       // 10个int元素，每个初始化为-1
list<string> svec(10, "hi");    // 10个字符串；每个元素是"hi"  
forward_list<int> ivec(10);     // 10个元素，每个初始化为0
deque<string> svec(10);         // 10个元素，每个都是空字符串
```

**注意点**
* ⚠️ 接受大小参数的构造函数仅对**顺序容器**有效，**关联容器**(如`set`, `map`)不支持


---

<a id="id16"></a>
## ✅ 知识点5.4: 固定大小数组

**理论**
* 与内置数组一样，库`array`的**大小**是其类型的一部分
* 定义`array`时，除了指定**元素类型**，还要指定**容器大小**
* `array`**不支持**普通的容器构造函数

**教材示例代码**
```cpp
array<int, 42>;          // 类型是：保存42个int的array
array<string, 10>;       // 类型是：保存10个string的array

array<int, 10>::size_type i;  // array类型包括元素类型和大小
array<int>::size_type j;      // 错误：array<int>不是类型
```

**`array`的特殊性质**
* 默认构造的`array`不为空：它具有与其大小**一样多**的元素
* 这些元素是**默认初始化**的，就像内置数组中的元素一样
* 如果**列表初始化**`array`，初始化器的数量必须**等于或小于**`array`的大小
  * 如果初始化器数量小于size, 剩下的会被**值初始化**
  * 如果元素类型是类类型，**必须**有默认构造函数才能进行值初始化

**教材示例代码**
```cpp
array<int, 10> ia1;          // 10个默认初始化的int
array<int, 10> ia2 = {0,1,2,3,4,5,6,7,8,9};  // 列表初始化
array<int, 10> ia3 = {42};   // ia3[0]是42，剩余元素是0

// 与内置数组不同，array可以复制和赋值
array<int, 10> digits = {0,1,2,3,4,5,6,7,8,9};
array<int, 10> copy = digits;  // 正确：只要array类型匹配
```

**注意点**
* ⚠️ 虽然不能复制或分配**内置数组类型**的对象，但对`array`**没有**这样的限制, 但是类型和大小信息必须保证相同

---

<a id="id17"></a>
## ✅ 知识点6: 赋值和`swap`操作

**理论**
* 赋值相关运算符作用于**整个**容器
* 赋值运算符将左侧容器中的**整个元素范围**替换为右侧操作数元素的副本
* 不同于内置类型`array`, 标准库里面的`array`是**允许赋值**的，但是左右两边一定需要保证是**相同类型**
* 但是`array`容器**不支持**花括号赋值，只支持花括号初始化

**教材示例代码**
```cpp
c1 = c2;           // 用c2中元素的副本替换c1中的内容
c1 = {a,b,c};      // 赋值后c1的大小为3

array<int, 10> a1 = {0,1,2,3,4,5,6,7,8,9};
array<int, 10> a2 = {0}; // 所有元素都为 0

a1 = a2;    // ✔ 合法：把 a2 的内容拷贝到 a1
a2 = {0};  // ❌ 错误：不能用花括号列表给 array 赋值
```

**容器赋值操作表**

| 操作                             | 说明                              | 适用 / 要求 / 注意事项                                                               |
| ------------------------------ | ------------------------------- | ---------------------------------------------------------------------------- |
| `c1 = c2`                      | 将 `c1` 的元素替换为 `c2` 的拷贝          | `c1` 与 `c2` 必须为相同类型；会使指向 `c1` 的迭代器/引用/指针失效                                   |
| `c = {a, b, c...}`             | 用初始化列表的元素替换容器内容                 | 不适用于 `array`；会使迭代器/引用/指针失效；`assign(il)` 等价变体存在                               |
| `swap(c1, c2)` 或 `c1.swap(c2)` | 交换两个容器的内容（常比拷贝快得多）              | `c1` 与 `c2` 必须为相同类型；通常不会使迭代器/引用/指针失效（除了 `array`）；`string` 在 swap 后迭代器仍有效     |
| `seq.assign(b, e)`             | 用迭代器区间 `[b, e)` 的元素替换 `seq` 的内容 | 该区间的迭代器 `b`、`e` 不得指向 `seq`；`assign` 不适用于关联容器和 `array`；会使目标容器的迭代器/引用/指针失效，接受兼容类型的赋值   |
| `seq.assign(il)`               | 用初始化列表 `il` 替换 `seq` 的内容        | 与 `c = { ... }` 类似；不适用于关联容器和 `array`；会使目标容器的迭代器/引用/指针失效                      |
| `seq.assign(n, t)`             | 用 `n` 个值为 `t` 的元素替换 `seq` 的内容   | 不适用于关联容器和 `array`；会使目标容器的迭代器/引用/指针失效                                         |
| **通用警告**                       | 赋值相关操作会使指向左侧（被替换）容器的**迭代器、引用和指针失效** | 除了 `string`（swap 后迭代器仍有效）与 `swap`（通常不使迭代器失效，`array` 为例外）外，其他容器的赋值/assign 会失效 |



---

<a id="id18"></a>
## ✅ 知识点6.1: `assign`操作

**理论**
* 赋值运算符要求左右操作数具有**相同的类型**
* 顺序容器（除了`array`）还定义了一个名为`assign`的成员，接受两个迭代器并允许我们从**不同但兼容**的类型赋值，或从容器的**子序列**赋值
* `assign`操作将左侧容器中的**所有元素**替换为其迭代器指定的元素的副本

**教材示例代码**
```cpp
list<string> names;
vector<const char*> oldstyle;

names = oldstyle;  // 错误：容器类型不匹配

// 正确：从const char*到string的构造函数
names.assign(oldstyle.cbegin(), oldstyle.cend());

// 等效于slist1.clear(); 后跟 slist1.insert(slist1.begin(), 10, "Hiya!");
list<string> slist1(1);       // 一个元素，是空字符串
slist1.assign(10, "Hiya!");   // 十个元素；每个都是"Hiya!"
```

**注意点**
* ⚠️ 由于现有元素被替换，传递给`assign`的迭代器**不能是**被调用的`assign`的容器的迭代器
* 💡 `assign`的参数确定容器将拥有多少元素以及这些元素的值

---

<a id="id19"></a>
## ✅ 知识点6.2: `swap`操作

**理论**
* `swap`操作交换两个**相同类型**容器的内容
* 调用`swap`后，两个容器中的元素互换
* 除了`array`，交换两个容器保证**很快**—元素本身**不**被交换；内部数据结构被交换

**swap的特殊行为**
* 除了`array`，`swap`不复制、删除或插入任何元素，保证在恒定时间内运行
* 不挪动这些元素意味着除了`string`，调用`swap`**不会**使迭代器、引用和指针失效
  * 因为他们依旧指向的是`swap`前一样的元素
  * 但是着写被指向的元素(那块内存)已经在不同的容器中了- **值，地址不变，容器变**
* 如果对`string`使用`swap`的话， 会将迭代器，指针，引用都失效
* 交换两个数组**确实会**交换元素，需要与数组中元素数量成比例的时间
  * 指针，引用，迭代器依然不会失效并保持指向相同元素， 只不过元素值已经被交换 - **地址不变，仅值变**

**教材示例代码**
```cpp
vector<string> svec1(10);  // 包含10个元素的vector
vector<string> svec2(24);  // 包含24个元素的vector  
swap(svec1, svec2);        // 交换后svec1包含24个元素，svec2包含10个
```




**注意点**
* 🎯 在新库中(C++11)，容器提供`swap`的成员和非成员版本
* 💡 作为习惯，最好使用`swap`的**非成员版本**，因为其对于泛型编程及其重要

---

<a id="id20"></a>
## ✅ 知识点7: 容器大小操作

**理论**
* `size()`成员返回容器中的元素数量
* `empty()`返回一个bool，如果size为零则为true，否则为false
* `max_size()`返回大于或等于该类型容器可以包含的元素数量的数字

**注意点**
* ⚠️ forward_list提供max_size和empty，但不提供size
* 💡 empty通常比检查size() == 0更高效

---

<a id="id21"></a>
## ✅ 知识点8: 关系运算符

**理论**
* 每个容器类型都支持相等运算符（==和!=）
* 除了无序关联容器外，所有容器还支持关系运算符（>、>=、<、<=）
* 右操作数和左操作数必须是相同类型的容器，并且必须包含相同类型的元素

**比较规则**
* 如果两个容器大小相同且所有元素都相等，则两个容器相等；否则不相等
* 如果容器大小不同但较小容器的每个元素都等于较大容器的对应元素，则较小容器小于另一个
* 如果两个容器都不是另一个的初始子序列，则比较取决于比较第一个不相等元素

**教材示例代码**
```cpp
vector<int> v1 = {1, 3, 5, 7, 9, 12};
vector<int> v2 = {1, 3, 9};
vector<int> v3 = {1, 3, 5, 7};
vector<int> v4 = {1, 3, 5, 7, 9, 12};

v1 < v2     // true; v1和v2在元素[2]处不同；v1[2]小于v2[2]
v1 < v3     // false; 所有元素都相等，但v3的元素更少
v1 == v4    // true; 每个元素都相等且v1和v4大小相同
v1 == v2    // false; v2的元素比v1少
```

**注意点**
* ⚠️ 只有当元素类型定义了相应的比较运算符时，才能使用关系运算符比较两个容器
* 🔄 容器相等运算符使用元素的==运算符，关系运算符使用元素的<运算符

---

## 🔑 核心要点总结

1. **容器操作分层**：操作分为通用操作、顺序容器特定操作、关联容器特定操作
2. **迭代器范围**：使用[begin, end)左包含区间，是标准库的基础概念
3. **初始化多样性**：支持拷贝构造、范围构造、列表初始化等多种方式
4. **swap优化**：除array外，swap操作在常数时间内完成，只交换内部数据结构
5. **类型安全**：关系运算符要求容器类型和元素类型都匹配，并使用元素的比较运算符

## 📌 考试速记版

**口诀**：容器操作分三层，迭代范围左包含，swap优化不拷贝，比较需要类型同

**关键对比表**：
| 操作类型 | 适用容器 | 关键特点 |
|---------|----------|----------|
| 通用操作 | 所有容器 | 构造、赋值、大小检查 |
| 顺序容器操作 | vector, list, deque等 | 大小构造、assign |
| 关联容器操作 | set, map等 | 键值对操作 |
| 固定大小 | array | 大小是类型一部分 |

**特殊记忆点**：
- forward_list没有size()
- array支持赋值但不支持列表赋值
- swap在array上会真正交换元素
- 关系比较使用元素的<和==运算符