# 📘 第9章 容器 练习题评价

## 📋 总体概览

| 题目 | 得分 | 评价摘要 |
|------|------|----------|
| 9.35 | ⭐⭐⭐ 3/5 | 核心概念理解正确，但技术表述存在不准确之处 |
| 9.36 | ⭐⭐⭐⭐⭐ 5/5 | 回答完全正确，简洁明了 |
| 9.37 | ⭐⭐ 2/5 | 对`list`和`array`的理解存在关键性错误 |

---

## 🎯 逐题详细评价

### 9.35 解释vector的capacity和size的区别

**原题：** *Explain the difference between a vector's capacity and its size.*

**你的答案：**
> capacity表示的一个vector的实际或者物理容量， 一旦请求或者使用容量超过这个capacity的，编译器就会reallocate这个vector重新分配更大的capactiy
> 
> size表示的是当前已经被使用的容量， 也就是现在容器里所有元素所站的量
> 
> 总结一下就是两者区别就是size是瓶子中的水位， 而capacity是瓶子的容量

**批改结果：** ⭐⭐⭐ 3/5

- **概念理解：** ⚠️ 基本正确但不够精确。你把握住了核心区别（capacity是总空间，size是已用空间），但"请求或使用容量超过capacity"的表述存在逻辑矛盾——实际是`size()`达到`capacity()`时触发扩容
- **代码质量：** N/A（理论题）
- **逻辑完整：** ✅ 水瓶类比形象生动，有助于理解。但未提及扩容策略和`capacity >= size`的不变关系
- **表达清晰：** ⚠️ "编译器就会reallocate"不准确——是**标准库实现**而非编译器负责内存管理

**正确答案：**
```cpp
// 核心区别：
// size() 返回当前vector中元素的实际数量
// capacity() 返回在不重新分配内存的情况下可容纳的元素总数

// 关系：size() <= capacity()
// 当 size() == capacity() 且继续添加元素时，vector会：
// 1. 分配更大的内存块（通常按倍数增长，如1.5x或2x）
// 2. 将现有元素移动到新内存
// 3. 释放旧内存
```


---

### 9.36 容器能否让capacity小于size？

**原题：** *Can a container have a capacity less than its size?*

**你的答案：**
> 不可能， 违反规律， capacity 只能大于或等于size

**批改结果：** ⭐⭐⭐⭐⭐ 5/5

- **概念理解：** ✅ 完全正确！准确抓住了`capacity()`和`size()`的不变关系
- **逻辑完整：** ✅ 回答简洁但涵盖了核心要点
- **表达清晰：** ✅ 表述直接明确

**正确答案：**
```cpp
// 对于vector，capacity() >= size() 是始终成立的不变式
// 原因：capacity代表已分配的内存空间，size代表已使用的空间
// 不可能出现已使用空间超过已分配空间的情况
```


---

### 9.37 为什么list和array没有capacity成员？

**原题：** *Why don't list or array have a capacity member?*

**你的答案：**
> list没有是因为数据结构设计完全和vector不同， list不像是vector一样紧密排列一个挨着一个的， list的元素更像是一个一个的单体相互链接着， list没有size更没有capacity了
> 
> array没有是因为考虑到，本来就是非常原始的类型，没有实现， vector就是为了解决这个问题

**批改结果：** ⭐⭐ 2/5

- **概念理解：** ❌ 存在根本性错误：
  - `list` **有`size()`成员函数**（C++11起标准要求），你的"没有size"说法错误
  - `array`不是"非常原始的类型"，而是**标准库容器**，固定大小是其设计意图
- **逻辑完整：** ⚠️ `list`部分解释了链表特性，但结论错误；`array`解释完全偏离概念
- **表达清晰：** ❌ "vector就是为了解决这个问题"表述模糊，未说清解决什么问题

**正确答案：**
```cpp
// std::list 没有capacity()的原因：
// list是双向链表，每个节点独立分配内存，元素不连续存储
// 新增元素只需单独分配一个节点，不涉及整体内存重分配
// 因此"预留容量"的概念对list没有意义

// std::array 没有capacity()的原因：
// array是固定大小数组，大小在编译时确定不可变
// capacity()表示"在不重分配内存下可容纳的元素数"
// 对于array，这个值永远等于size()，所以capacity()概念冗余
```



