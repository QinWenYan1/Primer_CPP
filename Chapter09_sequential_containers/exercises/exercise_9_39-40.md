## 📊 练习批改与分析

### Exercise 9.39: 程序片段解释

**原题：** 解释以下程序片段的作用：
```cpp
vector<string> svec;
svec.reserve(1024);
string word;
while (cin >> word)
    svec.push_back(word); 
```

**你的答案：**
> 这段代码是先预约了一个能存1024个string元素的capacity , 将在下次扩容的时候触发
> 
> 在第一次push_back的时候， svec的capacity 直接扩容到1024

**批改：** ⭐⭐ 2/5分 - 基本理解但存在关键概念错误

**详细分析：**
- ✅ **理解基本意图**：你认识到`reserve(1024)`与容量预约有关，抓住了核心目标
- ❌ **时机错误**：`capacity`在调用`reserve(1024)`时就**立即**设置为1024，而不是在第一次`push_back`时才扩容。这是关键概念混淆
- ⚠️ **表述模糊**："将在下次扩容的时候触发"说法不够准确，`reserve`是直接分配空间，不是触发某种延迟机制

**正确答案：**
```cpp
// 创建一个空的string向量
vector<string> svec;
// 立即为向量预留1024个元素的存储空间，避免后续push_back时的多次重新分配
// 此时svec.capacity() == 1024，svec.size() == 0
svec.reserve(1024);
string word;
// 从标准输入读取单词，直到遇到EOF或错误
while (cin >> word)
    svec.push_back(word);  // 在前1024次push_back期间不会重新分配内存
```



---

### Exercise 9.40: 容量变化分析

**原题：** 如果上一个程序读取256个单词，重新分配后其容量 likely 是多少？如果读取512？1000？1048呢？

**你的答案：**
> 由于预定了capacity为1024了， 那么在尾到达1024前， capacity不会变所以256, 512, 或者1000个后依然是1024capacity 但是到1048个后， sve就会扩容了这个依然还是看标准库
> 
> resize不会改变capacity, 除非往大于当前capacity的方向扩容

**批改：** ⭐⭐⭐ 3/5分 - 部分正确但存在混淆和多余信息

**详细分析：**
- ✅ **前半正确**：256、512、1000个单词时`capacity`保持1024的理解基本正确（这些数量<1024）
- ✅ **扩容判断**：认识到1048会触发扩容是正确的
- ⚠️ **表述不精确**：扩容后的容量取决于具体实现（通常是翻倍至2048），但"依然还是看标准库"表述过于模糊
- ❌ **概念混淆**：后半部分突然讨论`resize`与`capacity`的关系，但题目涉及的是`reserve`和`push_back`，无关`resize`。这显示出概念边界不清晰
- ❌ **术语错误**：将"capacity"说成了"尾"，用词不够专业

**正确答案：**
- **256个单词后**：`capacity` = 1024（未超过预留量）
- **512个单词后**：`capacity` = 1024（未超过预留量）
- **1000个单词后**：`capacity` = 1024（未超过预留量）
- **1048个单词后**：当添加第1025个元素时，会发生重新分配。标准库不规定具体策略，但**通常**会翻倍至2048。因此1048个单词后，`capacity` likely为2048（实现定义）




---
