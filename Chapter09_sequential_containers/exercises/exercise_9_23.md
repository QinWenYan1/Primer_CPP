## 📊 练习批改与分析

### Exercise 9.23 访问元素的值

**原题：** In the first program in this section on page 346, what would the values of val, val2, val3, and val4 be if c.size() is 1?

```cpp
if (!c.empty()) {
    auto val = *c.begin(), val2 = c.front();
    auto last = c.end();
    auto val3 = *(--last); 
    auto val4 = c.back(); 
}
```

**你的答案：** 
```
val会是c元素里面值的副本
val2会是c容器里面的元素值的副本
val3，val4也是c元素里面的值副本
```

**批改：** ⭐⭐⭐ 3/5（良好答案，主要思路正确，存在重要细节问题）

**详细分析：**
- ✅ **概念理解基本正确**：你认识到`val`、`val2`、`val3`和`val4`都是容器中元素值的副本，这抓住了`auto`会推导出非引用类型的关键点。
- ✅ **对函数作用的理解准确**：你知道`c.begin()`、`c.front()`、`c.back()`等操作都与容器元素相关。
- ⚠️ **答案不够完整和精确**：题目明确问"what would the values be"，需要具体说明这些值是什么关系。当`c.size()`为1时，这四个变量都等于**同一个元素**的值，即它们彼此相等。你的答案没有明确指出这一点。
- ⚠️ **表达可以更清晰**：使用"c元素里面值的副本"这样的表述不够精确，可以更明确地说明是"容器中唯一元素的值的副本"。

**正确答案：**
当`c.size()`为1时，`val`、`val2`、`val3`和`val4`的值都等于容器`c`中唯一元素的值的副本，因此它们彼此相等。

解释过程：
1. `c.begin()`返回指向第一个（也是唯一）元素的迭代器，解引用后得到该元素的引用，`auto val`会推导出元素类型（去除引用），所以`val`是该元素的副本。
2. `c.front()`返回第一个元素的引用，同样`auto val2`推导出元素类型，所以`val2`也是该元素的副本。
3. `c.end()`返回尾后迭代器，`--last`将其递减，指向最后一个元素（也是第一个元素），解引用得到该元素的引用，`auto val3`推导出元素类型，所以`val3`也是该元素的副本。
4. `c.back()`返回最后一个元素（也是第一个元素）的引用，`auto val4`推导出元素类型，所以`val4`同样是该元素的副本。

