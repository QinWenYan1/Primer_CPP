# 📘 顺序容器章节知识表

> 来源：C++ Primer 第9章章节总结 | 涵盖：顺序容器的核心概念、容器类型、适配器及迭代器相关术语

---

| 类别 | 概念 | 定义 | 关键点 |
|------|------|------|--------|
| 🧱 **容器基础** | `container` | 持有特定类型对象集合的类型，每个库容器都是模板类型。除array外均为可变大小。 | • 模板类型，需指定元素类型 • 统一的标准化接口 • 自动管理元素生命周期 |
| 🧱 **容器基础** | `sequential container` | 持有单一类型有序集合的类型，元素按位置访问，元素顺序由添加位置决定。 | • 按位置访问 • 有序集合 • 不同容器性能特征各异 |
| 🧱 **容器基础** | `iterator range` | 由一对迭代器表示的元素范围，首迭代器指向第一个元素，尾迭代器指向最后一个元素的下一位置。 | • 左闭合区间 `[begin, end)` • 空范围时两迭代器相等 • 通过递增首迭代器遍历元素 |
| 🧱 **容器基础** | `left-inclusive interval` | 包含首元素但不包含尾元素的范围，记作 `[i, j)`，即从i开始包含i但不包含j的序列。 | • 标准库通用表示法 • 空范围判断：`i == j` • 非空范围可递增首迭代器到达尾迭代器 |
| 📦 **具体容器** | `vector` | 顺序容器，支持通过位置索引的快速随机访问，只能在尾部高效添加/删除元素。 | • 快速随机访问 • 尾部操作高效 • 中间插入导致后续迭代器失效 • 扩容可能整体重新分配 |
| 📦 **具体容器** | `deque` | 顺序容器，支持通过位置索引的快速随机访问，在头尾两端都支持快速插入删除，插入删除不移动其他元素。 | • 头尾操作都高效 • 随机访问 • 插入不使迭代器失效 • 双端队列结构 |
| 📦 **具体容器** | `list` | 表示双向链表的顺序容器，元素只能顺序访问，支持任意位置的快速插入删除。 | • 双向链表 • 只能顺序访问 • 插入/删除不使其他迭代器失效 • 支持`++`和`--` |
| 📦 **具体容器** | `forward_list` | 表示单链表的顺序容器，元素只能顺序访问，只支持单向遍历（无`--`操作）。 | • 单链表结构 • 插入/删除在迭代器位置**之后**进行 • 有"起止前"迭代器 • 删除只失效指向该元素的迭代器 |
| 📦 **具体容器** | `array` | 固定大小的顺序容器，除需指定元素类型外还必须给出大小，支持快速随机访问。 | • 大小固定 • 定义时需要指定大小 • 不可动态扩展 • 栈上分配 |
| 🔄 **迭代器** | `begin` | 容器操作，返回指向容器中第一个元素的迭代器；若容器为空则返回尾后迭代器。返回迭代器是否为const取决于容器类型。 | • 首元素访问 • 空容器返回end() • const性取决于容器类型 |
| 🔄 **迭代器** | `end` | 容器操作，返回指向容器中最后一个元素的**下一位置**的迭代器。返回迭代器是否为const取决于容器类型。 | • 尾后迭代器(off-the-end) • 不可解引用 • 用作遍历结束标记 |
| 🔄 **迭代器** | `cbegin` | 容器操作，返回指向容器中第一个元素的**const_iterator**；若容器为空则返回尾后迭代器。 | • 总是返回const迭代器 • 保证不修改元素 |
| 🔄 **迭代器** | `cend` | 容器操作，返回指向容器最后一个元素的下一位置的**const_iterator**。 | • 总是返回const尾后迭代器 • 与cbegin()配对使用 |
| 🔄 **迭代器** | `off-the-end iterator` | 表示范围中最后一个元素之后位置的迭代器，通常称为"end迭代器"。 | • 遍历终止标记 • `end()`返回 • 不可解引用 |
| 🔄 **迭代器** | `off-the-beginning iterator` | 表示`forward_list`中起始元素之前位置的迭代器，由`before_begin()`返回，与end()迭代器类似，不可解引用。 | • 专用于forward_list • 在首元素前插入时使用 • 不可解引用 |
| 🔧 **容器适配器** | `adaptor` | 给定类型、函数或迭代器后使其表现得像另一者的库类型、函数或迭代器。三种顺序容器适配器：stack、queue、priority_queue，每个适配器在底层顺序容器类型上定义新接口。 | • 接口转换机制 • 基于现有容器实现 • 限制而非扩展功能 • 代码复用设计模式 |
| 🔧 **容器适配器** | `stack` | 顺序容器适配器，产生只允许在一端添加和删除元素的类型。 | • LIFO（后进先出）策略 • 默认基于deque实现 • 可用vector/list • 只暴露栈操作接口 |
| 🔧 **容器适配器** | `queue` | 顺序容器适配器，产生允许在尾部添加、头部删除的类型，支持FIFO策略。 | • FIFO（先进先出）策略 • 默认基于deque实现 • 也可用list • 提供front()/back()访问 |
| 🔧 **容器适配器** | `priority_queue` | 顺序容器适配器，产生按指定优先级而非顺序插入元素的队列。 | • 优先级排序 • 默认基于vector实现 • 也可用deque • 默认使用`<`运算符确定优先级（最大堆） |

---

## 🔑 章节核心要点总结

1. **统一接口**：所有顺序容器共享标准化接口，相同操作在不同容器上具有相同含义
2. **动态内存**：除array外所有容器都提供高效动态内存管理，自动处理存储分配
3. **迭代器失效**：添加/删除元素的操作可能使迭代器、指针或引用失效，需谨慎操作
4. **性能权衡**：不同容器在随机访问、插入删除、内存占用等方面各有优劣
5. **适配器模式**：容器适配器通过限制底层容器接口提供新的数据结构抽象

---

## 📌 考试速记要点

**术语记忆技巧**：
- **容器三要素**：模板类型、元素存储、自动管理
- **访问方式**：vector/deque/array（随机访问） vs list/forward_list（顺序访问）
- **适配器本质**：接口转换、底层依赖、操作限制
- **迭代器对**：cbegin/cend（const）、begin/end（可变）
- **失效规则**：中间插入/删除会失效后续迭代器（vector/string）