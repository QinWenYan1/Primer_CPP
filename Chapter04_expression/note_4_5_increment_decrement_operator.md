# 📘 4.5 Increment and Decrement Operators (自增与自减运算符)

> 基于《C++ Primer》第五版。本节介绍 `++` 与 `--` 运算符的两种形式（前置与后置）、它们在表达式中的求值方式，以及常见的用法与注意点。

---

## 🧠 本节核心概念

* 前置自增/自减 (prefix increment/decrement)
* 后置自增/自减 (postfix increment/decrement)
* 前置与后置的区别：返回值与性能
* 在复合表达式中的结合与优先级
* 常见注意点：避免副作用与未定义行为
* 前置与后置运算符的优先级和结合性

---

## ✅ 前置与后置运算符 (Prefix vs. Postfix)

**定义 / 理论**

* `++` / `--` 是一元运算符，作用于 **左值 (lvalue)**。
* **前置形式** (`++i`, `--i`)：对对象先修改，再返回修改后的对象本身（lvalue）。
* **后置形式** (`i++`, `i--`)：先保存原值，返回原值的副本（rvalue），再修改对象。

**教材示例代码**

```cpp
int i = 0, j;
j = ++i;   // i 先自增为 1，再返回 1 赋给 j → j = 1, i = 1
j = i++;   // 返回 i 的原值 1 赋给 j，然后 i 自增 → j = 1, i = 2
```

**注意点**

* ⚠️ 前置返回 **对象本身 (lvalue)**，可继续用作赋值
* ⚠️ 后置返回 **副本 (rvalue)**，不能作为赋值目标

---

## ✅ 效率与推荐写法

**定义 / 理论**

* 后置运算符需要保存“未修改前”的副本 → 可能增加开销。
* 内置类型（如 `int`）通常被优化，不显著；但对 **迭代器** 可能更昂贵。
* 因此， **如果我们用不到副本的话， 就使用前置版本**来避免不必要的开销

**教材示例代码**

```cpp
for (auto it = v.begin(); it != v.end(); ++it) {
    cout << *it << " ";  // 推荐使用 ++it
}
```

**注意点**

* ⚠️ 除非需要旧值，否则推荐用 **前置形式 (++i)**。

---

## ✅ 知识点 3：结合解引用与自增

**定义 / 理论**

* **后置`++` 的优先级高于 `*`**，因此 `*p++` 等价于 `*(p++)`。
* 表达式 `*p++`：解引用 p 的当前值，然后 p 自增。

**教材示例代码**

```cpp
auto p = v.begin();
// 打印元素直到遇到负数为止
while (p != v.end() && *p >= 0) {
    cout << *p++ << endl; // 打印当前元素，然后指针前移
}
```

**注意点**

* ⚠️ `*p++` 是常见习惯用法，但对初学者容易混淆。
* ⚠️ 必须理解 → `p++` 返回原指针的副本，再做解引用。

**建议**

* 多使用 **`*p++`** 这种写法， 因为这种写法易读且不容易出错

---

## ✅ 未定义行为与顺序问题

**定义 / 理论**

* C++ 大多数运算不保证求值顺序。
* 如果同一对象在一个表达式中既被修改又被使用，结果未定义。

**教材示例代码（未定义行为）**

```cpp
while (beg != s.end() && !isspace(*beg))
    *beg = toupper(*beg++);  // ❌ 未定义行为
```

**正确写法**

```cpp
while (beg != s.end() && !isspace(*beg)) {
    *beg = toupper(*beg); // 修改当前字符
    ++beg;                // 再前移
}
```

**注意点**

* ⚠️ 避免在一个表达式里又改又用同一对象。

---


## ✅ 前置与后置运算符的优先级和结合性

**定义 / 理论**

* **后置自增/自减** (`iter++`, `iter--`)

  * 优先级高于解引用 `*`。
  * 表达式 `*iter++` 被解析为 `*(iter++)`。
  * 意味着“先解引用旧元素，再迭代器后移”。

* **前置自增/自减** (`++iter`, `--iter`)

  * 与解引用 `*`、取地址 `&`、逻辑非 `!` 等处于 **同一优先级**。
  * 这些运算符是 **右结合**。
  * 表达式 `++*iter` 被解析为 `++(*iter)`，即“先解引用，再对元素自增”。

**示例代码**

```cpp
// 假设 iter 是 vector<int>::iterator
*iter++;     // 等价于 *(iter++)   → 先取当前元素，再移动到下一个
++*iter;     // 等价于 ++(*iter)   → 让当前元素值自增
*(++iter);   // 明确写法          → 先移动迭代器，再取下一个元素
```

**注意点**

* ⚠️ `std::string` 这样的类型没有 `operator++`，因此 `++*iter` 会报错。
* ⚠️ 一定要区分 `*iter++`（操作迭代器）与 `++*iter`（操作元素）。
* ⚠️ 如果语义需要“先移再取”，必须写明括号：`*(++iter)`。

---


## 🔑 小结

* `++i` / `--i` → 前置，返回修改后的对象（lvalue）；`i++` / `i--` → 后置，返回原值副本（rvalue）。
* 推荐使用前置形式，避免不必要的副本开销。
* `*p++` → 等价于 `*(p++)`，常用于迭代器遍历。
* 避免副作用和顺序依赖，否则可能触发未定义行为。

---

## 📌 考试速记版

* **口诀**：前置改自己，后置留备份。
* **推荐**：`++i` 比 `i++` 更高效。
* **小心**：修改 + 使用同一对象 → 未定义。



