# 📘 Chapter 4.8 The Bitwise Operators (位运算符)

> 本节内容源自 C++ Primer 4.8 节，主要讲解了用于位操作的位运算符（`~`, `<<`, `>>`, `&`, `|`, `^`）的用法、特性及其注意事项。同时强调了与逻辑运算符的区别，并提供了一个使用位运算管理学生测验成绩的案例。

---

## 🧠 本节核心概念（提纲目录）

*   位运算符概述与基本规则
*   按位取反运算符 (`~`)
*   移位运算符 (`<<`, `>>`)
*   按位与、或、异或运算符 (`&`, `|`, `^`)
*   位运算符与逻辑运算符的混淆警告
*   位运算实战案例：管理测验成绩
*   移位运算符的优先级与结合性（重载与IO）

---

## ✅ 位运算符概述与基本规则 (Overview and Rules)

**定义 / 理论**
*   位运算符将其**整型**操作数视为**位的集合**，允许测试和设置单个位。
*   操作数可以是带符号或无符号类型。但如果操作数是**有符号的负值**，其**符号位的处理方式取决于机器**，且**改变符号位的左移操作是未定义行为**。
*   “小整型”操作数（如 `char`）会首先被**整型提升**（integral promotion）。
*   我们可以


**运算符表 (Table 4.3. Bitwise Operators (Left Associative))**
| Operator | Function       | Use           |
| :------: | :------------- | :------------ |
|   `~`    | bitwise NOT    | `~expr`       |
|   `<<`   | left shift     | `expr1 << expr2` |
|   `>>`   | right shift    | `expr1 >> expr2` |
|   `&`    | bitwise AND    | `expr1 & expr2`  |
|   `^`    | bitwise XOR    | `expr1 ^ expr2`  |
|   `\|`    | bitwise OR     | `expr1 \| expr2`  |

**注意点**
*   ⚠️ 操作数必须是整型或可转换为整型的枚举类型。不能用于浮点型。
*   ⚠️ 右操作数（对于移位运算符）必须是非负数且严格小于结果类型的位数，否则行为未定义。
*   ⚠️ 出于可移植性和安全性的考虑，**只对 `unsigned` 类型使用位运算符**。

---


## ✅ 知识点：`std::bitset` （拓展/非必读）

* **定义**：`std::bitset<N>` 是一个 **固定长度为 N 的二进制位序列容器**。

* **初始化**：可用整数或二进制字符串。

  ```cpp
  bitset<8> b1(42);        // 00101010
  bitset<8> b2("1100");    // 00001100
  ```

* **常用操作**：

  * `b.any()` / `b.none()` / `b.count()`
  * `b.set(i)` / `b.reset(i)` / `b.flip(i)`
  * `b.to_string()` / `b.to_ulong()`

* **特点**：

  * **固定长度**（编译期决定）。
  * 提供丰富的位运算接口。
  * 常用于二进制打印、掩码操作。

* **与 `vector<bool>` 区别**：

  * `bitset` → **固定长度**，适合位运算。
  * `vector<bool>` → **动态长度**，适合存储大量布尔值。

---


## ✅ 按位取反运算符 (`~`) (Bitwise NOT)

**定义 / 理论**
*   一元运算符，将其操作数的每一位取反（1变0，0变1）。
*   操作数会被提升（如 `char` 提升为 `int`），提升的高位在取反时也会被处理，也就是全部取1

**教材示例代码**
```cpp
unsigned char bits = 0227; // 8位: 10010111 (八进制227)
// 提升为 int (假设32位): 00000000 00000000 00000000 10010111
~bits; // 结果: 11111111 11111111 11111111 01101000
```

**注意点**
*   ⚠️ 对 `char` 等小类型取反时，结果是一个高位全为1的大整数。

---

## ✅ 移位运算符 (`<<`, `>>`) (Shift Operators)

**定义 / 理论**
*   `expr1 << expr2`: 将 `expr1` 的所有位向左移动 `expr2` 位。在**右侧**插入 `0` 值位。
*   `expr1 >> expr2`: 将 `expr1` 的所有位向右移动 `expr2` 位。
    *   **`expr2` 不能为负数，值必须严格小于结果类型的位宽**，否则结果未定义
    *   溢出位会被直接**丢弃**
    *   结果是一个新值，这个新值是基于左侧操作数（可能经过整型提升后）修改的副本
    *   对于**无符号**类型，在**左侧**插入 `0` 值位
    *   对于**有符号**类型，在**左侧**插入的内容是**实现定义**的——可能是符号位的副本，也可能是 `0`

**教材示例代码**
```cpp
//例子假定了char有8位, int有32位
unsigned char bits = 0233; // 8位: 10011011
bits << 8; // 结果类型被升为整形，然后左移8位: 00000000 00000000 10011011 00000000
bits >> 3; // 右移3位，最左边的三位丢弃，: 00000000 00000000 00000000 00010011
```

**注意点**
*   ⚠️ **左移可能改变符号位**，对于有符号类型，这是**未定义行为**。再次强调**使用无符号类型**

---

## ✅ 按位与、或、异或运算符 (`&`, `|`, `^`) (AND, OR, XOR)

**定义 / 理论**
*   `&` (AND): 两位都为1时，结果才为1。
*   `|` (OR): 两位中有一个为1时，结果就为1。
*   `^` (XOR): 两位不相同时，结果为1（相异为真）。

**教材示例代码**
```cpp
unsigned char b1 = 0145; // 二进制: 01100101
unsigned char b2 = 0257; // 二进制: 10101111

b1 & b2;             // 结果: 24位0 00100101 (二进制AND)
b1 | b2;             // 结果: 24位0 11101111 (二进制OR)
b1 ^ b2;             // 结果: 24位0 11001010 (二进制XOR)
```

**注意点**
*   ⚠️ 这些运算符同样会对操作数进行整型提升。


---

## ✅ 位运算符与逻辑运算符的混淆警告 (Common Confusion)

**定义 / 理论**
*   这是一个常见的错误：混淆位运算符和逻辑运算符。
*   `&` (bitwise AND) vs `&&` (logical AND)
*   `|` (bitwise OR) vs `||` (logical OR)
*   `~` (bitwise NOT) vs `!` (logical NOT)

**注意点**
*   ⚠️ 逻辑运算符将整个操作数视为一个布尔值，并返回 `true` 或 `false`，且具有短路求值特性。
*   ⚠️ 位运算符独立地操作操作数的每一位，并返回一个整数值，没有短路求值。

---

## ✅ 位运算实战案例：管理测验成绩 (Practical Example: Quiz Scores)

**定义 / 理论**
*   位运算是一种高效存储大量布尔值的方法
*   使用一个无符号整数的每一位来代表一个学生的测验通过（1）或未通过（0）。
*   `quiz1` 的每一位表示一位同学， `unsigned long`起码会有32位在机器上
*   `1UL << 27` 设置第一位为1， 并且将1移动到第27位表示第27位学生通过考试

**教材示例代码**
```cpp
unsigned long quiz1 = 0; // 初始化，所有位为0

// 1. 设置位：表示学生27通过测验
quiz1 |= (1UL << 27); // 创建一个只有第27位为1的掩码，然后OR操作

// 2. 清除位：表示学生27未通过测验
quiz1 &= ~(1UL << 27); // 创建一个只有第27位为0的掩码，然后AND操作

// 3. 检查位：检查学生27的成绩
bool status = quiz1 & (1UL << 27); // 如果第27位为1，则结果为非零（true）
```

**注意点**
*   ⚠️ `1UL` 表示 `unsigned long` 类型的字面值，确保有足够的位数。
*   ⚠️ 计数通常从**最低有效位（LSB）** 开始为0。

---

## ✅ 移位运算符的优先级与结合性（重载与IO）(Precedence and Associativity)

**定义 / 理论**
*   移位运算符是**左结合**的。
*   它们具有**中等优先级**：低于算术运算符，但高于关系、赋值和条件运算符
*   因此， 我们常常需要括号去组织操作符的运算优先级
*   IO库（`cout`, `cin`）重载了 `<<` 和 `>>` 运算符，它们与内置的移位运算符具有**相同的优先级和结合性**。

**教材示例代码**
```cpp
cout << "hi" << " there" << endl;
// 左结合，等价于: ((cout << "hi") << " there") << endl;

cout << 42 + 10;   // 正确: + 优先级高于 <<, 输出 52
cout << (10 < 42); // 正确: 括号强制优先级，输出 1
cout << 10 < 42;   // 错误! 等价于 (cout << 10) < 42;
```

**注意点**
*   ⚠️ 正是因为重载运算符保持了原有的优先级，所以在混合使用IO和关系运算时，**必须使用括号**来强制所需的计算顺序。

---

## 🔑 小结

1.  位运算符直接操作整数中的位，适用于底层编程和优化存储。
2.  使用无符号类型可以避免有符号数移位和位操作的未定义及实现定义行为。
3.  位运算符与逻辑运算符功能不同，极易混淆，需特别注意。
4.  移位运算符 `<<` 和 `>>` 的左结合性及中等优先级影响了复杂表达式的求值顺序。
5.  使用位掩码技术可以高效地管理一组布尔标志。

---

## 📌 考试速记版

*   **操作数**：整型，**强烈推荐 `unsigned`**。
*   **功能**：
    *   `~`：按位取反。
    *   `<<`：左移，**右侧补0**。
    *   `>>`：右移，**无符号左侧补0**，有符号实现定义。
    *   `&`：全1则1 (AND)。
    *   `|`：有1则1 (OR)。
    *   `^`：不同则1 (XOR)。
*   **警告**：勿与 `&&`, `||`, `!` 混淆。
*   **技巧**：
    *   **设位**：`value |= (1 << n);`
    *   **清位**：`value &= ~(1 << n);`
    *   **查位**：`if (value & (1 << n)) {...}`
*   **优先级**：算术 > 移位 > 关系 > 赋值 > 条件。
*   **结合性**：移位运算符**左结合**。