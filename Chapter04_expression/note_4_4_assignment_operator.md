# 📘 4.4 Assignment Operators（赋值运算符）

> 基于《C++ Primer》第五版。本节讨论 **赋值运算符** 的语法规则，包括左操作数要求、类型转换、初始化列表赋值、右结合性、优先级、复合赋值运算符，以及常见错误与注意事项。

---

## 🧠 本节核心概念

* 赋值操作符
* 赋值结果本身是 **左值**（类型与左操作数一致）
* 右侧操作数会发生 **隐式转换**
* 支持 **初始化列表赋值**（类类型可重载）
* 赋值运算符是 **右结合**
* 赋值运算符的 **优先级低**
* **复合赋值运算符**（`+=, -=, *=, /=, %=, <<=, >>=, &=, ^=, |=`）

---

## ✅ 赋值操作符

**定义 / 理论**

* 左操作数必须是 **可改动的左值**
* 字面值（如 `1024`）、算术表达式（如 `i+j`）、const 对象都不能出现在左侧

**示例代码**

```cpp
int i = 0, j = 0, k = 0; //初始化，不是赋值
const int ci = i; //初始化，不是赋值

1024 = k;   // ❌ 错误：字面值是 rvalue
i + j = k;  // ❌ 错误：表达式结果是 rvalue
ci = k;     // ❌ 错误：ci 是 const，不可修改
```
**注意**
- ⚠️ 赋值和初始化是两回事，不能混为一谈

---

## ✅ 赋值结果的类型与隐式转换

**定义 / 理论**

* 赋值表达式的结果是其 **左操作数**，且是左值。
* 如果两侧类型不同，右操作数会被转换为左侧类型。

**示例代码**

```cpp
int k = 0;       
k = 3.14159;    // k == 3, double → int 截断
```

⚠️ **注意**：可能发生精度丢失或窄化错误。

---

## ✅ 初始化列表赋值（C++11）

**定义 / 理论**

* 内置类型最多只能接收一个值，且不能窄化转换。
* 类类型（如 `vector`）可定义自己的赋值运算符，允许用列表整体替换。
* 当用空 `{}` 做赋值时，编译器会生成一个 **值初始化**（value-initialized）也就是默认初始化的临时对象，然后赋给左操作数

**示例代码**

```cpp
k = {3.14};          // ❌ 错误：narrowing conversion
vector<int> vi;
vi = {0,1,2,3,4,5};  // ✅ vi 现在有 6 个元素
```

---

## ✅ 赋值运算符是右结合

**定义 / 理论**

* `=` 是右结合运算符：`ival = jval = 0;` 等价于 `ival = (jval = 0);`
* 更细的来说相当于: `jval = 0;` `ival = jval;` 

**示例代码**

```cpp
int ival;
double jval;
ival = jval = 1.1; // jval=1.1, 然后 ival=jval,截断为 1, ival = 1
jval = ival = 1.1 // 截断 ival = 1, 然后 jval = ival, 也就是 1.0 
//注意上下两者的区别
```

**注意点**

* ⚠️ 多重赋值时，每个对象必须类型兼容，或者类型可以转换为兼容

```cpp
int ival, *pval;
ival = pval = 0;  // ❌ 错误：int* 不能赋值给 int。pval无法赋值给ival
string s1, s2;
s1 = s2 = "OK"; // string字面值可以转换为string变量
```

---

## ✅ 赋值的优先级低

**定义 / 理论**

* `=` 的优先级低于大多数运算符（如 `!=`）
* 在条件表达式中，通常需要加括号
* 赋值在**条件表达式**中非常有用

**示例代码**

```cpp
int i;
while ((i = get_value()) != 42) {
    // 正确，i 获取新值并与 42 比较
}
```
**解释**
- 这种条件表达式更能清晰表达我们的目的 - 我们想持续运行道 `get_value` 返回42
- 这个条件表达式通过赋值给`i`变量然后将`i`与42比较来实现
- 如果没有括号的话， `!=` 符号将于`get_value`返回变量比较， 然后将比较结果传递给`i`

⚠️ 常见错误：

```cpp
if (i = j)   // 这是赋值，不是比较！
```

---

## ✅ 复合赋值运算符

**定义 / 理论**

* 形式：`a op= b` 等价于 `a = a op b`，但左操作数只求值一次
* 提供的算术和位运算符均有复合形式

**示例代码**

```cpp
int sum = 0;
for (int val = 1; val <= 10; ++val)
    sum += val;   // 等价于 sum = sum + val
```

支持：`+=, -=, *=, /=, %=, <<=, >>=, &=, ^=, |=`

---

## ⚠️ 注意点

* ⚠️ 左操作数必须是 **非 const 左值**
* ⚠️ 窄化转换（如 `double → int`）可能报错或截断
* ⚠️ `=` 的优先级低于比较，条件语句要加括号
* ⚠️ `if (i = j)` 是合法语法，但常常是 bug，应写 `if (i == j)`

---

## 🔑 小结

* 赋值运算符左侧必须是可修改的左值。
* 赋值结果是左值，类型与左操作数相同。
* 支持列表赋值（内置 ≤1 元素，类类型可扩展）。
* `=` 是右结合，且优先级低。
* 常用复合赋值简化表达式，效率更高。

---

## 📌 考试速记版

* 左侧必须是 **modifiable lvalue**
* 结果 = 左值，类型同左侧
* `=` 右结合，优先级低
* **复合赋值**：`a += b` → `a = a + b`
* ⚠️ `if (i = j)` 小心，这是赋值！

