# 📘 Chapter 4.9 The sizeof Operator (sizeof 运算符)

> 本节内容源自 C++ Primer 4.9 节，主要讲解了 `sizeof` 运算符的用法、特性及其返回值规则。`sizeof` 用于获取一个类型或表达式结果类型的大小（以字节为单位），其特点是不会对操作数进行求值。

---

## 🧠 本节核心概念（提纲目录）

*   `sizeof` 运算符的基本形式与返回值类型
*   `sizeof` 运算符的右结合性与不求值特性
*   对各类操作数使用 `sizeof` 的结果规则
*   使用 `sizeof` 计算数组元素个数
*   `sizeof` 在编译时的作用

---

## ✅ `sizeof` 运算符的基本形式与返回值 (Basic Forms and Return Type)

**定义 / 理论**
*   `sizeof` 运算符返回一个**类型**或一个**表达式结果类型所占的字节数**。
*   它是一个**右结合**的**编译时**运算符。
*   返回值是 `size_t` 类型的**常量表达式**。`size_t` 是一种定义在 `<cstddef>` 头文件中的与机器相关的无符号整数类型，足够大以表示内存中任何对象的大小。
*   有两种形式：
    1.  `sizeof (type)`
    2.  `sizeof expr` - 返回的是表达式`expr`的**结果类型**的大小，而**不是**表达式本身的大小。

**教材示例代码**
```cpp
Sales_data data, *p; // 假设一个类类型 Sales_data

sizeof(Sales_data);  // Sales_data 类型本身的大小
sizeof data;         // data 的类型的大小，即 sizeof(Sales_data)
sizeof p;            // 指针的大小（通常4或8字节）
sizeof *p;           // p 所指向类型的大小，即 sizeof(Sales_data)
sizeof data.revenue; // Sales_data 的 revenue 成员的类型的大小
sizeof Sales_data::revenue; // C++11: 获取类成员类型大小的另一种方式
```

**解析**:
*   值得注意的是 C++11 标准之前，要获取一个类的某个成员的大小，你必须有一个该类的对象。但在 C++11 及之后，你可以直接使用作用域运算符 (`::`) 来获取类成员的大小，而无需创建类的实例

**注意点**
*   ⚠️ 第二种形式 `sizeof expr` 中，`sizeof` 并不会计算表达式 `expr` 的值，它只分析并确定其类型。

---

## ✅ `sizeof` 的右结合性与不求值特性 (Right Associativity and Unevaluated Context)

**定义 / 理论**
*   `sizeof` 是右结合的，且与解引用运算符 `*` 具有相同的优先级。因此 `sizeof *p` 等价于 `sizeof (*p)`。
*   **最关键的特性**：`sizeof` **不会对其操作数进行求值**。操作数在编译时仅用于类型分析。

**教材示例代码与解析**
```cpp
int *p = nullptr; // 甚至是一个无效的未初始化指针
sizeof(*p);       // 安全！返回 sizeof(int)。*p 不会被实际解引用。
```
**解析**：
*   `sizeof(*p)` 只需要知道 `p` 是一个指向 `int` 的指针，因此 `*p` 的类型是 `int`。它根本不需要去访问 `p` 所指向的内存，所以即使 `p` 是空指针或未初始化，这也是安全的。

**注意点**
*   ⚠️ 这个“不求值”的特性使得 `sizeof` 非常安全，可以用于任何表达式而不会引发运行时错误（如解引用空指针、调用未定义的函数等）。

---

## ✅ 对各类操作数使用 `sizeof` 的结果规则 (Rules for Different Operands)

**定义 / 理论**
`sizeof` 的结果取决于操作数的类型：
*   **`char`**：`sizeof(char)`、`sizeof signed char`、`sizeof unsigned char` 结果均为 **1**。（C++标准保证）
*   **引用类型**：返回**被引用对象**所占的大小。
    ```cpp
    int x = 10;
    int &r = x;
    sizeof(r); // 返回 sizeof(int)，而不是引用本身的大小
    ```
*   **指针类型**：返回**存储一个地址所需**的大小（通常4或8字节）。
*   **解引用指针**：返回**指针所指向类型**的大小。指针本身是否有效无关紧要。
*   **数组类型**：返回**整个数组**所占的字节数（`元素大小 × 元素个数`）。**`sizeof` 不会将数组转换为指针**。
    ```cpp
    int arr[10];
    sizeof(arr); // 返回 10 * sizeof(int)
    ```
*   **`string` 或 `vector`**：只返回这些类型**固定部分**的大小（即它们内部的书本结构，如指针、大小等），而**不会**返回其动态分配的、用于存储元素的内存大小。
    ```cpp
    std::vector<int> v(1000); // v 管理着1000个int
    sizeof(v);                // 返回的大小可能只有24字节左右（取决于实现），而不是4000字节
    ```

**注意点**
*   ⚠️ 对于类类型，`sizeof` 会返回其所有非静态数据成员的大小之和，并可能包含编译器插入的用于对齐的填充字节（padding）。

---

## ✅ 知识点 4：使用 `sizeof` 计算数组元素个数 (Calculating Array Size)

**定义 / 理论**
因为 `sizeof(数组)` 返回整个数组的字节大小，而 `sizeof(*数组)` 或 `sizeof(数组[0])` 返回单个元素的字节大小，所以可以用除法求出数组的元素个数。

**教材示例代码**
```cpp
int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; // 定义一个数组

// 计算数组元素个数：总大小 / 单个元素大小
constexpr size_t array_size = sizeof(ia) / sizeof(*ia); 
// 等价于: sizeof(ia) / sizeof(ia[0]);
// constexpr 因为 sizeof 返回常量表达式

int arr2[array_size]; // ok: array_size 是常量表达式
```

**注意点**
*   ⚠️ 这种方法**只适用于真正的数组**，不适用于通过指针传递的数组或动态数组，因为那时 `sizeof(指针)` 返回的是指针大小，而不是整个数组的大小。

---

## ✅ `sizeof` 在编译时的作用 (Compile-Time Evaluation)

**定义 / 理论**
*   `sizeof` 的操作是在**编译时**完成的。编译器根据类型信息即可确定结果，无需等到运行时
*   其结果是一个**常量表达式**，因此可以用于需要常量表达式的地方，例如数组的维度、`case` 标签、模板元编程等

**注意点**
*   ⚠️ 正因为是编译时操作，`sizeof` 不会带来任何运行时开销

---

## 🔑 小结

1.  `sizeof` 用于在编译时查询类型或表达式的大小，返回 `size_t` 类型的常量表达式。
2.  它的关键特性是**不对其操作数进行求值**，因此使用起来非常安全。
3.  对于数组，`sizeof` 返回整个数组的大小，可用于计算静态数组的元素个数。
4.  对于标准库容器（如 `vector`, `string`），`sizeof` 返回的是容器对象本身的控制结构的大小，而不是其管理的动态内存的大小。

---

## 📌 考试速记版

*   **形式**：`sizeof(type)` 或 `sizeof expr`
*   **返回值**：`size_t` 类型，字节大小。
*   **特性**：**右结合**，**不求值**操作数。
*   **规则**：
    *   `sizeof(char) == 1`
    *   对引用、解引用指针：返回**目标类型**大小。
    *   对指针：返回**指针自身**大小。
    *   对数组：返回**整个数组**大小。
    *   对`vector/string`：返回**固定控制块**大小。
*   **技巧**：`sizeof(arr) / sizeof(arr[0])` → 求静态数组元素个数。