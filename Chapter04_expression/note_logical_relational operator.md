# 📘 4.3 Logical and Relational Operators（逻辑与关系运算符）

> 基于《C++ Primer》第五版。本节讨论逻辑与关系运算符，包括逻辑非、逻辑与、逻辑或、比较运算符（<, <=, >, >=, ==, !=），它们的语义、优先级、短路求值特性，以及与 `bool` 类型的交互。

---

## 🧠 本节核心概念

* 逻辑与关系运算符
* 逻辑与 (`&&`) 与逻辑或 (`||`) 的短路求值
* 逻辑非 (`!`) 运算符
* 关系运算符 `<, <=, >, >=`
* 等于和不等于 `==, !=`
* 与 `bool` 类型的交互与警告

---

## ✅ 逻辑与关系运算符

**定义 / 理论**
- 逻辑与关系运算符返回 `bool`，操作数可以是算术类型或指针类型（隐式转换为布尔）
- 它们都 **左结合**
- 操作数的值为0的会返回 `false`，其余都返回 `true`
- 操作数都是 **rvalue**，结果也是 **rvalue** 


---

## ✅ 逻辑与 (`&&`) 和逻辑或 (`||`) 的短路求值

**定义 / 理论**

* **逻辑与**：若左操作数为 `false`，右操作数不会被求值。
* **逻辑或**：若左操作数为 `true`，右操作数不会被求值。
*  这种只在必要时(无法决定结果时)才计算右侧的行为叫 **短路求值 (short-circuit evaluation)**
* 我们常依赖这种方法使用左操作数去测试**计算右操作数是否安全**，例如：
`index != s.size() && !isspace(s[index])`

**示例代码**

```cpp
for (const auto &s : text) {       // 遍历 text 中的每个 string，s 是 const 引用
    cout << s;                     // 打印当前元素

    // 如果是空行，或者最后一个字符是句号
    if (s.empty() || s[s.size() - 1] == '.')  
        cout << endl;              // 换行
    else
        cout << " ";               // 否则打印一个空格分隔
}
```
**解释**
1. **遍历方式**

   * 使用 `for (const auto &s : text)` 遍历 `text` 容器。
   * `s` 是 **const 引用**，避免了复制大对象 `string` 的开销，同时保证元素不会被修改。

2. **逻辑与短路求值 ||**

   * 条件 `s.empty() || s[s.size()-1] == '.'`：

     * 若 `s` 为空字符串，**左操作数为 true**，此时短路 → 不会去访问右边的 `s[s.size()-1]`，避免越界错误
     * 若 `s` 不为空，则继续检查最后一个字符是否是 `.`

3. **输出逻辑**

   * 空行或者句号结尾 → 输出换行。
   * 其他情况 → 输出空格，保证字符串之间有间隔。


**注意点**

* ⚠️ 短路求值常用于避免未定义行为（如除零、越界访问）
* ⚠️ 逻辑与/或的求值顺序是从左到右

---

## ✅ 逻辑非 (`!`)

**定义 / 理论**

* 返回布尔值的反转：`true → false`, `false → true`
* 操作数会转换为布尔类型

**示例代码**

```cpp
bool b = true;
cout << !b; // 输出 0
```

**注意点**

* ⚠️ `!` 优先级高于关系运算符。

---

## ✅ 关系运算符 `<, <=, >, >=`

**定义 / 理论**

* 比较算术值或指针值，结果为布尔。
* 左结合。

**示例代码**

```cpp
int a = 3, b = 5;
if (a < b) cout << "a<b";   // true
```

**注意点**

* ⚠️ 不要链式比较（`i < j < k`），因为 `i < j` 先被计算为 `bool`，再和 `k` 比较。

```cpp
if (i < j < k) // 实际比较 (i < j) 的 bool 与 k
if (i < j && j < k >) // 正确写法
```

---

## ✅ 等于和不等于 `==, !=`

**定义 / 理论**

* 用于比较两个值是否相等或不等。
* 左结合。

**示例代码**

```cpp
int a = 42, b = 42;
if (a == b) cout << "equal";
if (a != b) cout << "not equal";
```

**注意点**

* ⚠️ 避免将 `==` 写成 `=`。
* ⚠️ 与 `bool` 比较时要直接使用 `if (val)`，不要写 `if (val == true)`。

---

## ✅ 与 `bool` 类型交互

**定义 / 理论**

* 任意算术值或指针值会隐式转换为布尔：

  * 非零 → `true`
  * 零 → `false`

**示例代码**

```cpp
int x = 10;
if (x) cout << "true";  // 等价于 (x != 0)
if ( val == true ); // ture只有当val为1时
```

**解释**


1. **比较时的隐式转换**

   * 如果 `val` 不是 `bool`，而是算术类型（如 `int`），表达式 `val == true` 会先把 `true` 转换成 `1`，再和 `val` 比较。
   * 这等价于：

     ```cpp
     if (val == 1) { /* ... */ }
     ```

2. **布尔到整型的转换规则**

   * `false → 0`
   * `true → 1`
   * 所以 `if (val == true)` 实际就是在判断 `val` 是否等于 1。

3. **问题与推荐写法**

   * 如果我们想检查 `val` 是否为真（非零即可），直接写 `if (val)`。
   * 如果我们真的想检查 `val` 是否等于 **1**，应该直接写 `if (val == 1)`。



**注意点**

* ⚠️ **不要用 `true` 和 `false` 字面值直接做比较**，如 `if (val == true)`，多余并且 **`bool`字面值只允许和 `bool` 类型去比较**，否者结果不会达到预期

---

## 🔑 小结

* 逻辑与关系运算符返回 `bool`，大多数为左结合，唯独 `!` 是右结合。
* `&&` 与 `||` 使用 **短路求值**，常用于避免错误。
* 关系运算符不能链式比较。
* 判断布尔条件时直接用 `if (val)`，避免写 `if (val == true)`。
* **优先级表格** (双横线隔开的为一类) 

   | Associativity | Operator | Function      | Use            |   
   | ------------- | -------- | ------------- | -------------- | 
   | Right         | !        | logical NOT   | `!expr`        | 
   |  
   | Left          | <        | less than     | `expr < expr`  | 
   | Left          | <=       | less or equal | `expr <= expr` |   
   | Left          | >        | greater than  | `expr > expr`  |   
   | Left          | >=       | greater or eq | `expr >= expr` |
   |  
   | Left          | ==       | equality      | `expr == expr` |   
   | Left          | !=       | inequality    | `expr != expr` | 
   |  
   | Left          | &&       | logical AND   | `expr && expr` | 
   |  
   | Left          | \|\|     | logical OR    | `expr \|\| expr`|


---

## 📌 考试速记版

* **优先级**：`!` 高于关系运算符，高于 `&&`，最后是 `||`
* **短路求值**：`&&` 左 false 停止，`||` 左 true 停止
* **链式比较**：`i < j < k` 错 → 先算 bool
* **布尔判断口诀**：直接 `if (val)`，不要 `== true`
