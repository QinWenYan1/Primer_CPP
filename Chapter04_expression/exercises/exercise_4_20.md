### (a) `*iter++;`

* **你的说法：**“先解引用得到值，再对值自增（legal）”
* **更正：**`++` 的优先级高于 `*`，表达式等价于 `*(iter++)`。
  **行为是**：解引用**当前元素**（得到 `string&`，结果被丢弃），然后**迭代器自增**到下一个位置；**不是**对字符串做自增。
  **结论：**✅ **合法**（但要求原来的 `iter` 可解引用，不能是 `end()`）。

---

### (b) `(*iter)++;`

* **你的说法：**“legal，效果同上”
* **更正：**`*iter` 的类型是 `string&`，而 `std::string` **没有** `operator++`。
  **结论：**❌ **不合法**（对 `string` 做 `++` 是编译错误）。

---

### (c) `*iter.empty()`

* **你的说法：**“报错，`.` 优先级更高，会去查找 iterator 的成员”
* \*\*补充更正：\*\*会被解析为 `*(iter.empty())`：

  1. 先调用 `iter.empty()` —— 但**迭代器没有 `empty()` 成员**；
  2. 即便有，它通常返回 `bool`，也**不能对 `bool` 解引用**。
     **结论：**❌ **不合法**。若想判断字符串是否为空，应写 `(*iter).empty()` 或 `iter->empty()`。

---

### (d) `iter->empty();`

* **你的说法：**“legal，去查找 iterator 所指对象的成员”
* **结论：**✅ **合法**。等价于 `(*iter).empty()`，检查当前字符串是否为空，返回 `bool`。

---

### (e) `++*iter;`

* **你的说法：**“效果同 `++*iter`（并判为 legal）”
* \*\*更正：\*\*这条就是 `++*iter` 本身，等价于 `++(*iter)`，对 `string&` 做前置 `++`。
  `std::string` **没有** `operator++`。
  **结论：**❌ **不合法**。

---

### (f) `iter++->empty();`

* **你的说法：**“legal，先查成员，再向下一个元素移动”
* **更正说明：**后置 `++` 产生**旧迭代器的副本**，对这个副本调用 `->empty()`；表达式求值后，`iter` 自增。
  **行为是**：检查**当前元素**是否为空，然后把 `iter` 前移一位。
  **结论：**✅ **合法**（前提是原 `iter` 可解引用）。

---

## 最终判定

* **合法：**(a)、(d)、(f)
* **不合法：**(b)、(c)、(e)

> 小口诀：
>
> * `*iter++` ≡ `*(iter++)`（解引用当前，再把迭代器往后移）。
> * `->` == `(*iter).`
> * `std::string` **不能**做 `++`。
