# 📘 13.3. 交换函数 (Swap)

> 来源说明：C++ Primer 13.3 | 本节涵盖：为何以及如何为管理资源的类定义自定义的 `swap` 函数，以及如何利用 `swap` 实现安全的赋值运算符（拷贝并交换技术）。

---

## 🧠 核心概念总览（严格按原文顺序）

* [*知识点1: 为什么需要自定义 Swap*](#id1)
* [*知识点2: 编写自定义的 swap 函数*](#id2)
* [*知识点3: swap 函数应调用 swap 而非 std::swap*](#id3)
* [*知识点4: 在赋值运算符中使用 swap（拷贝并交换）*](#id4)

---

<a id="id1"></a>
## ✅ 知识点1: 为什么需要自定义 Swap

**理论**
* **核心主旨总结**：
    * 对于管理资源的类（例如动态内存），除了定义拷贝控制成员，通常还需要定义自己的 `swap` 函数。
        * 这对于计划在重新排列元素的算法（如 `std::sort`）中使用的类尤为重要，因为这些算法会调用 `swap` 来交换两个元素。
        * **自定义 `swap` 可以避免默认 `swap` 带来的不必要的资源拷贝和分配**。
* **默认 `swap` 的行为**：
    * 库的 `swap` 函数通过一次拷贝和两次赋值来实现交换。
    * 对于像 `HasPtr` 这样管理 `string` 的类，这会导致被交换的 `string` 被拷贝多次，并分配新的内存，**效率低下**。
* **期望的优化**：理想的交换方式是只交换内部的指针成员，而不是复制它们所指向的 `string` 数据本身，从而避免内存分配。

**注意点**
* ⚠️ **`swap` 的必要性**：
    * 与拷贝控制成员不同，定义 `swap` **不是必须的**。但对于分配资源的类，定义 `swap` 是一种重要的优化手段。
    * 此优化依赖于类内部使用指针来间接管理资源（如动态分配的字符串或数组），这样交换指针的成本远低于拷贝整个资源。

**教材示例代码**
```cpp
// 默认 swap 的低效实现（概念上）
HasPtr temp = v1; // 拷贝构造，分配新string并拷贝v1的string
v1 = v2;          // 赋值操作，分配新string并拷贝v2的string
v2 = temp;        // 赋值操作，分配新string并拷贝temp的string

// 期望的高效交换（仅交换指针）
string *temp = v1.ps;
v1.ps = v2.ps;
v2.ps = temp;
```

---

<a id="id2"></a>
## ✅ 知识点2: 编写自定义的 swap 函数

**理论**
* **核心主旨总结**：
    * 可以通过在类内部定义一个接受两个类类型引用参数的 `swap` **友元函数**，来覆盖该类的默认交换行为。
    * 典型的实现是交换对象的每个数据成员。
* **实现步骤**：
    1. 在类内声明 `swap` 为 `friend`，使其能访问私有成员。
    2. 将 `swap` 定义为 `inline` 函数以优化性能。
    3. 在函数体内，对对象的每个数据成员调用 `swap` 进行交换。

**注意点**
* 📋 **术语提醒**：`swap` 函数是一个非成员函数，但通常是类的友元(`friend`)。
* 💡 **理解技巧**：自定义 `swap` 的核心思想是“交换对象的内部表示”，对于管理指针的类，就是交换指针本身。

**教材示例代码**
```cpp
class HasPtr {
    friend void swap(HasPtr&, HasPtr&); // 声明为友元
    // ... 其他成员
};

inline
void swap(HasPtr &lhs, HasPtr &rhs) {
    using std::swap; // 重要：使用 using 声明
    swap(lhs.ps, rhs.ps); // 交换指针，而不是 string 数据
    swap(lhs.i, rhs.i);   // 交换 int 成员
}
```
---

<a id="id3"></a>
## ✅ 知识点3: `swap`函数应调用`swap`而非`std::swap`

**理论**
* **核心主旨总结**：
    * 在自定义的 `swap` 函数中，交换数据成员时，**必须使用未限定的 `swap` 调用**，而不是 `std::swap`。
    * 这样做可以确保如果某个成员类型有自己专属的 `swap` 版本，就会调用那个更高效的版本；如果没有，则通过 `using std::swap` 引入的声明，会回退到调用 `std::swap`。
* **错误示例**：
    * 如果类 `Foo` 有一个 `HasPtr` 类型的成员 `h`，在 `Foo` 的 `swap` 函数中错误地调用 `std::swap(lhs.h, rhs.h)`，那么即使 `HasPtr` 有自定义 `swap`，这里也只会调用低效的库版本，失去优化效果。
* **正确做法**：
    * 在函数作用域内使用 `using std::swap;`，然后对所有成员进行未限定的 `swap` 调用。

**注意点**
* ⚠️ **重要细节**：**每个对 `swap` 的调用都必须是未限定的**（即直接写 `swap(...)`，而不是 `std::swap(...)`）。
* 🔄 **知识关联**：这里涉及到 C++ 的名字查找与函数匹配规则（后续章节会解释）。简单来说，未限定的调用会先在参数类型所在命名空间寻找更好的匹配。
* 💡 **理解技巧**：记住口诀 **“先 `using std::swap;`，再调 `swap`”**。


**教材示例代码**
```cpp
// 错误的 Foo swap 版本（失去了 HasPtr 的优化）
void swap(Foo &lhs, Foo &rhs) {
    // WRONG: 显式调用了库版本，不会使用 HasPtr 的 swap
    std::swap(lhs.h, rhs.h);
    // ... 交换 Foo 的其他成员
}

// 正确的 Foo swap 版本
void swap(Foo &lhs, Foo &rhs) {
    using std::swap; // 引入 std::swap 到当前作用域
    swap(lhs.h, rhs.h); // 未限定调用，优先匹配 HasPtr::swap
    // ... 交换 Foo 的其他成员
}
```

---

<a id="id4"></a>
## ✅ 知识点4: 在赋值运算符中使用 swap（拷贝并交换）

**理论**
* **核心主旨总结**：定义了 `swap` 的类，常用一种名为**拷贝并交换(copy and swap)**的技术来实现赋值运算符。此技术通过**按值传递右侧运算对象**，然后与左侧运算对象(`*this`)交换临时副本的内容来实现赋值。
* **工作原理**：
    1. **参数传递**：赋值运算符的参数是 `HasPtr rhs`，即右侧对象的一个**副本**。这调用了拷贝构造函数，完成了资源的独立拷贝。
    2. **交换内容**：调用 `swap(*this, rhs)`，将 `*this` 的旧资源与 `rhs` 中新拷贝的资源进行交换。
    3. **清理资源**：函数返回时，局部变量 `rhs` 被销毁，其析构函数会释放它现在持有的资源（即 `*this` 原来的资源）。
* **主要优点**：此技术**自动正确处理了自我赋值(self-assignment)和异常安全(exception safety)**，且代码简洁。

**教材示例代码**
```cpp
// 注意 rhs 是按值传递的，HasPtr 的拷贝构造函数
// 会将右侧运算对象中的 string 拷贝到 rhs 中
HasPtr& HasPtr::operator=(HasPtr rhs) {
    // 将左侧运算对象的内容与局部变量 rhs 交换
    swap(*this, rhs); // rhs 现在指向本对象曾使用的内存
    return *this;     // rhs 被销毁，从而 delete 了 rhs 中的指针
}
```

**注意点**
* ⚠️ **参数形式**：注意这个赋值运算符的参数是**非引用类型**，这是“拷贝并交换”技术的关键。
* 💡 **异常安全**：唯一可能抛出异常的操作发生在拷贝构造 `rhs` 时（例如 `new` 失败）。此时左侧对象 `*this` 的状态尚未被改变，因此是异常安全的。
* 💡 **自我赋值处理**：在自我赋值（如 `a = a`）时，按值传参会创建 `a` 的一个副本，然后与 `a` 自身交换。当临时副本销毁时，会释放与原来相同的资源，结果是 `a` 保持不变，这是正确的行为。
* 📋 **术语提醒**：**拷贝并交换(copy and swap)** 是一种通用的、健壮的赋值运算符实现模式。

---

## 🔑 核心要点总结
1.  **自定义 `swap` 是优化**：对于管理资源的类，自定义 `swap` 通过直接交换内部指针（而非资源本身）来大幅提升交换效率，这对标准库算法尤其重要。
2.  **正确调用 `swap`**：在自定义的 `swap` 函数体内，交换成员时应使用未限定的 `swap` 调用（先 `using std::swap;`），以确保能调用到成员类型可能存在的、更优化的特化版本。
3.  **拷贝并交换技术**：利用自定义的 `swap` 函数，通过“按值传参创建副本 -> 与 `*this` 交换 -> 副本析构释放旧资源”的模式来实现赋值运算符。这种方法代码简洁，且自动保证了**异常安全**和**正确处理自我赋值**。
4.  **`swap` 与赋值运算符的关系**：自定义 `swap` 不仅是独立的优化，也是实现高级赋值操作（拷贝并交换）的基础构件。

## 📌 考试速记版
*   **自定义 `swap` 签名**：`friend void swap(MyClass&, MyClass&);`，通常是 `inline`。
*   **`swap` 实现关键**：函数内 `using std::swap;`，然后对每个成员调用 `swap(mem1, mem2)`。
*   **拷贝并交换赋值运算符**：
    ```cpp
    MyClass& operator=(MyClass rhs) { // 按值传参！
        swap(*this, rhs);
        return *this;
    }
    ```
*   **两大优势**：**自动异常安全**、**自动处理自我赋值**。
*   **易错点**：在自定义 `swap` 中错误地写 `std::swap(member1, member2)`，会错过成员类型的优化 `swap`。

**记忆口诀**：资源类，写 `swap`；交换指针效率佳。实现时，要留心，调用 `swap` 不限名。赋值运算有妙招，拷贝交换是法宝，传值交换再析构，安全自赋全做到。