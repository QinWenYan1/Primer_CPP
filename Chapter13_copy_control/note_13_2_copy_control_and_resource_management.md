# 📘 13.2. 拷贝控制与资源管理 (Copy Control and Resource Management)

> 来源说明：C++ Primer 13.2 | 本节涵盖：管理类外资源的类必须定义拷贝控制成员，并探讨了使类表现得像“值”或像“指针”的两种设计选择及实现。

---

## 🧠 核心概念总览（严格按原文顺序）

* [*知识点1: 管理资源的类必须定义拷贝控制成员*](#id1)
* [*知识点2: 拷贝操作的两种语义选择：值 vs 指针*](#id2)
* [*知识点3: 像值的类的定义与实现*](#id3)
* [*知识点4: 像值的类的拷贝赋值运算符*](#id4)
* [*知识点5: 编写拷贝赋值运算符的关键概念*](#id5)
* [*知识点6: 错误的拷贝赋值运算符实现示例*](#id6)
* [*知识点7: 像指针的类的实现思路*](#id7)
* [*知识点8: 引用计数的工作原理*](#id8)
* [*知识点9: 引用计数的存储位置问题*](#id9)
* [*知识点10: 引用计数版HasPtr类定义*](#id10)
* [*知识点11: 指针语义类的析构函数实现*](#id11)
* [*知识点12: 指针语义类的拷贝赋值运算符实现*](#id12)

---

<a id="id1"></a>
## ✅ 知识点1: 管理资源的类必须定义拷贝控制成员

**理论**
* **核心主旨总结**：
    * 当一个类的成员管理着类外的资源通常情况下（即指向外部资源的指针）时，
    * 这个类**必须定义拷贝控制成员（拷贝构造函数、拷贝赋值运算符、析构函数）**。
* 因为这类类需要自己定义**析构函数来释放对象分配的资源**。
* 一旦一个类需要一个**析构函数**，那么它也几乎肯定需要**拷贝构造函数和拷贝赋值运算符**。

---

<a id="id2"></a>
## ✅ 知识点2: 拷贝操作的两种语义选择：值 vs 指针

**理论**
* **核心主旨总结**：
    * 在定义拷贝操作前，我们通常有两种设计选择：
        * 使类表现得像一个**值(value)**。
        * 或者像一个**指针(pointer)**。
* **像值的类 (Valuelike)**：
  * 拥有自己的状态。
  * 拷贝时，副本和原对象**相互独立**。修改副本不影响原对象，反之亦然。
  * 标准库中的容器和`string`类就具有值语义。
* **像指针的类 (Pointerlike)**：
  * 共享状态。
  * 拷贝时，副本和原对象**共享底层数据**。修改副本会影响原对象，反之亦然。
  * `shared_ptr`类具有指针语义。
* **两者都不是**：
    * `unique_ptr`和IO类型不允许拷贝或赋值，因此它们**两者都不是**。

---

<a id="id3"></a>
## ✅ 知识点3: 像值的类的定义与实现

**理论**
* **核心主旨总结**：为了实现**值语义**，每个对象都必须拥有自己的一份资源副本。对于`HasPtr`类，这意味着每个对象都必须有自己的`string`副本。
* 需要以下成员：
  1. **拷贝构造函数**：拷贝底层的`string`，而不是仅仅拷贝指针。
  2. **析构函数**：释放`string`。
  3. **拷贝赋值运算符**：释放对象现有的`string`，并拷贝右侧运算对象的`string`。

**教材示例代码**
```cpp
class HasPtr {
public:
    HasPtr(const std::string &s = std::string()) :
        ps(new std::string(s)), i(0) { }
    // 每个HasPtr都有自己的ps指向的string的副本
    HasPtr(const HasPtr &p):
        ps(new std::string(*p.ps)), i(p.i) { }
    HasPtr& operator=(const HasPtr &);
    ~HasPtr() { delete ps; }
private:
    std::string *ps;
    int i;
};
```

**代码解析**
* 构造函数使用`new`在堆上分配新的`string`。 
* 析构函数使用`delete`释放它。
* 拷贝构造函数也使用`new`分配全新的、独立的内存。

---

<a id="id4"></a>
## ✅ 知识点4: 像值的类的拷贝赋值运算符

**理论**
* **核心主旨总结**：
    * **valuelike的拷贝赋值运算符通常结合了析构函数和拷贝构造函数的工作**：
        * 像**析构函数**一样，它需要销毁左侧运算对象的资源。
        * 像**拷贝构造函数**一样，它需要从右侧运算对象拷贝数据。
* **关键要求**：
    * 这些操作必须以正确的顺序执行，以确保在**对象给自己赋值（自赋值）** 时也能正确工作。
    * 同时，在可能的情况下，应该编写能够**在发生异常时保持左侧运算对象有效状态**的赋值运算符。
* **安全模式**：
    * 一种安全的做法是**先拷贝右侧运算对象**。
    * 拷贝完成后，再释放左侧运算对象的资源，最后将指针更新为指向新分配的字符串。

**教材示例代码**
```cpp
HasPtr& HasPtr::operator=(const HasPtr& rhs)
{
    auto newp = new string(*rhs.ps); // 拷贝底层的string
    delete ps;                       // 释放旧内存
    ps = newp;                       // 从rhs拷贝数据到本对象
    i = rhs.i;
    return *this;                    // 返回本对象
}
```

---

<a id="id5"></a>
## ✅ 知识点5: 编写拷贝赋值运算符的关键概念

**理论**
* **核心主旨总结**：编写赋值运算符时需要牢记两点：
  1.  **必须正确处理自赋值**。
  2.  **大多数赋值运算符需要共享析构函数和拷贝构造函数的工作**。
* **一个良好模式的特点**：
  1.  将右侧运算对象拷贝到一个局部临时对象中。
  2.  拷贝完成后，安全地销毁左侧运算对象的现有成员。
  3.  销毁完成后，将数据从临时对象拷贝到左侧运算对象的成员中。

---

<a id="id6"></a>
## ✅ 知识点6: 错误的拷贝赋值运算符实现示例

**理论**
* **核心主旨总结**：
    * 这个错误的示例演示了**如果不先拷贝就直接删除左侧资源，在发生自赋值时会导致灾难性后果**。
    * 因为删除`ps`会同时释放`rhs`和`*this`所指向的字符串（当它们是同一个对象时），后续的`new`操作会试图访问已释放的内存，导致未定义行为。

**注意点**
* ⚠️ **对于赋值运算符来说，即使在对象给自己赋值时也能正确工作至关重要**。
* ⚠️ 一个好的方法是**在销毁左侧运算对象之前先拷贝右侧运算对象**。

**教材示例代码**
```cpp
// 错误的赋值运算符写法！
HasPtr&
HasPtr::operator=(const HasPtr &rhs)
{
    delete ps;  // 释放本对象指向的string
    // 如果rhs和*this是同一个对象，我们就是在从已删除的内存拷贝！
    ps = new string(*(rhs.ps));
    i = rhs.i;
    return *this;
}
```

---

<a id="id7"></a>
## ✅ 知识点7: 像指针的类的实现思路

**理论**
* **核心主旨总结**：
    * 为了使`HasPtr`类表现得像指针，拷贝操作应该**拷贝指针成员本身，而不是它指向的`string`**。
* 类仍然需要自己的析构函数来释放构造函数分配的`string`:
    * 但析构函数不能单方面地释放它。
    * 只有当最后一个指向该`string`的`HasPtr`对象消失时，才能释放它。
* **最简单的方法**是使用`shared_ptr`来管理类中的资源。
    * `shared_ptr`会自己跟踪有多少用户共享指向的对象，并在没有用户时负责释放资源。
* 有时我们希望直接管理资源。
* 这时，使用**引用计数(reference count)** 会很有用。

---

<a id="id8"></a>
## ✅ 知识点8: 引用计数的工作原理

**理论**
* **核心主旨总结**：引用计数是实现指针语义和共享状态的一种手动管理技术。
* **工作原理**：
  * **构造函数（除拷贝构造）**：创建计数器，初始化为1，表示新创建的对象是资源的唯一用户。
  * **拷贝构造函数**：不分配新计数器。拷贝所有数据成员（包括指向计数器的指针），并**递增**这个共享的计数器，表示多了一个用户。
  * **析构函数**：**递减**计数器，表示少了一个用户。如果计数器变为0，则销毁共享状态（如字符串）。
  * **拷贝赋值运算符**：**递增**右侧运算对象的计数器，并**递减**左侧运算对象的计数器。如果左侧运算对象的计数器变为0，则销毁其状态。

---

<a id="id9"></a>
## ✅ 知识点9: 引用计数的存储位置问题

**理论**
* **核心主旨总结**：
    * 引用计数器**不能直接作为`HasPtr`对象的成员**。
    * 因为如果每个对象都有自己的计数器副本，当创建多个副本时，无法正确、同步地更新所有副本的计数器值。
* **解决方案**：将计数器**存储在动态内存中**。
  * 创建对象时，动态分配一个新的计数器。
  * 拷贝或赋值对象时，拷贝指向该计数器的指针。
  * 这样，副本和原对象就指向**同一个计数器**。

**教材示例代码**
```cpp
HasPtr p1("Hiya!");
HasPtr p2(p1); // p1 和 p2 指向同一个string
HasPtr p3(p1); // p1, p2 和 p3 都指向同一个string
// 问题：如果计数器是成员，创建p3时如何更新p2的计数器？
```

---

<a id="id10"></a>
## ✅ 知识点10: 引用计数版HasPtr类定义

**理论**
* **核心主旨总结**：
    * 这是一个具有指针语义、使用引用计数手动管理资源的`HasPtr`类定义。
    * 它新增了一个`use`指针成员，用于跟踪有多少对象共享`*ps`。

**教材示例代码**
```cpp
class HasPtr {
public:
    // 构造函数分配新的string和新的计数器，并将计数器置为1
    HasPtr(const std::string &s = std::string()) :
        ps(new std::string(s)), i(0), use(new std::size_t(1))
        { }
    // 拷贝构造函数拷贝所有三个数据成员并递增计数器
    HasPtr(const HasPtr &p) :
        ps(p.ps), i(p.i), use(p.use) { ++*use; }
    HasPtr& operator=(const HasPtr&);
    ~HasPtr();
private:
    std::string *ps;
    int i;
    std::size_t *use; // 用于跟踪有多少对象共享 *ps
};
```

**代码解析**
* 拷贝构造函数在初始化列表中拷贝了指针，并在函数体内递增了共享计数器。

---

<a id="id11"></a>
## ✅ 知识点11: 指针语义类的析构函数实现

**理论**
* **核心主旨总结**：
    * 具有指针语义和引用计数的类的析构函数**不能无条件删除`ps`**，因为可能还有其他对象指向该内存。
* 析构函数必须先递减引用计数。
* 只有当计数降为0时，才表示这是最后一个使用该资源的对象，此时才能安全地释放字符串和计数器本身。

**教材示例代码**
```cpp
HasPtr::~HasPtr() {
    if (--*use == 0) { // 如果引用计数变为0
        delete ps;     // 释放string
        delete use;    // 释放计数器
    }
}
```

---

<a id="id12"></a>
## ✅ 知识点12: 指针语义类的拷贝赋值运算符实现

**理论**
* **核心主旨总结**：
    * 引用计数版的拷贝赋值运算符结合了：
        * 拷贝构造函数（递增右侧计数）和
        * 析构函数（递减左侧计数并可能释放资源）的工作。
* **处理自赋值**：通过**先递增`rhs`的计数，再递减左侧对象的计数**来安全地处理自赋值。如果左右是同一对象，计数会在检查是否删除之前先被递增，从而防止了资源被过早释放。
* **执行步骤**：
  1. 递增右侧运算对象的引用计数。
  2. 递减左侧运算对象的引用计数，如果变为0，则释放其资源。
  3. 拷贝数据成员（`ps`, `i`, `use`）。
  4. 返回本对象。

**教材示例代码**
```cpp
HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
    ++*rhs.use;          // 递增右侧运算对象的引用计数
    if (--*use == 0) {   // 然后递减本对象的计数
        delete ps;       // 如果没有其他用户
        delete use;      // 释放本对象分配的资源
    }
    ps = rhs.ps;         // 从rhs拷贝数据到本对象
    i = rhs.i;
    use = rhs.use;
    return *this;        // 返回本对象
}
```

---

## 🔑 核心要点总结
1.  **必须定义拷贝控制**：管理类外资源的类必须定义拷贝构造函数、拷贝赋值运算符和析构函数。
2.  **两种设计范式**：根据拷贝操作的语义，类可以设计为具有“值语义”（独立副本）或“指针语义”（共享状态）。
3.  **值语义实现关键**：拷贝构造函数需要深拷贝资源；拷贝赋值运算符通常遵循“先拷贝右侧、再释放左侧、最后赋值”的模式，以**正确处理自赋值**。
4.  **指针语义实现关键**：通常使用**引用计数**来管理共享资源的生命周期。引用计数需要存储在动态内存中，供所有共享对象访问。析构函数和赋值运算符都需要小心地更新引用计数。

## 📌 考试速记版
*   **三法则**：需要析构函数的类，通常也需要拷贝构造和拷贝赋值。
*   **值 vs 指针**：值语义拷贝资源本身，副本独立；指针语义拷贝资源指针，副本共享。
*   **安全赋值模式**：`new` -> `delete` -> 拷贝。先处理右侧，再处理左侧，防自赋值。
*   **引用计数**：`use`指针在堆上。构造(+1)，拷贝构造(+1)，析构(-1, if 0 delete)，赋值(先右+1，再左-1)。
*   **常见陷阱**：赋值运算符未处理自赋值；指针语义类忘记更新或检查引用计数。

**记忆口诀**：
> 类管资源，三件套全。
> 值拷本体，指拷地址。
> 赋值先拷右，自赋不出丑。
> 指针要共享，计数来帮忙。