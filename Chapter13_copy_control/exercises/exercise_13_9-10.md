# 📘 C++ Primer 第13章 练习题评价

## 📋 总体概览

| 题目 | 得分 | 评价摘要 |
|------|------|----------|
| Exercise 13.9 | ⭐⭐ 2/5 | 基本理解析构函数概念，但存在重要概念错误和遗漏 |
| Exercise 13.10 | ⭐⭐ 2/5 | 部分理解智能指针销毁机制，但答案不完整且有错误 |

## 🎯 逐题详细评价

### Exercise 13.9 析构函数基础概念
**原题：** What is a destructor? What does the synthesized destructor do? When is a destructor synthesized?

**你的答案：**
```
析构函数就是在对象生命周期结束后， 对对象本身以及成员进行销毁

合成的析构函数也是同样的道理， 用于对对象销毁并释放内存, 

当对象被创建时
```

**批改结果：** ⭐⭐ 2/5
- **概念理解：** ❌ 对析构函数和合成析构函数的理解存在关键性错误
- **代码质量：** ⚠️ 无代码，但概念表述不准确
- **逻辑完整：** ❌ 答案不完整，缺失重要信息
- **表达清晰：** ⚠️ 有错别字，逻辑跳跃

**详细分析：**
- ❌ **概念错误1**：你说"合成的析构函数用于对对象销毁并释放内存" - 这是不准确的。合成析构函数**不会**自动释放动态分配的内存（除非使用智能指针）。对于原始指针成员，合成析构函数不会调用delete。
- ❌ **概念错误2**：你说"当对象被创建时"合成析构函数 - 这是完全错误的。析构函数在对象销毁时调用，而不是创建时。
- ❌ **答案不完整**：没有回答"什么时候合成析构函数"这个关键问题。
- ⚠️ **表述问题**：有错别字（"变味"应为"变为"），语句不够严谨。

**正确答案：**
```
1. 什么是析构函数？
   析构函数是特殊的成员函数，当对象生命周期结束时自动调用，用于释放对象所占用的资源。
   
2. 合成的析构函数做什么？
   合成的析构函数（默认析构函数）会按成员声明顺序调用每个成员的析构函数。
   对于类类型成员，调用其析构函数；对于内置类型成员，什么也不做。
   注意：合成析构函数不会delete指针成员指向的动态内存！

3. 什么时候合成析构函数？
   当类没有定义自己的析构函数时，编译器会为类合成一个析构函数。
```

---

### Exercise 13.10 StrBlob和StrBlobPtr的销毁
**原题：** What happens when a StrBlob object is destroyed? What about a StrBlobPtr?

**你的答案：**
```
当成员在析构函数中被销毁时，shared_ptr成员counter也变味0， 其指针指向的对象也同样被销毁， 内存被释放
```

**批改结果：** ⭐⭐ 2/5
- **概念理解：** ⚠️ 部分理解shared_ptr工作机制，但忽略了关键点
- **代码质量：** ⚠️ 无代码，概念表述需要更精确
- **逻辑完整：** ❌ 只回答了StrBlob，完全忽略了StrBlobPtr
- **表达清晰：** ⚠️ 有错别字，表述不够准确

**详细分析：**
- ✅ **正确部分**：你理解了shared_ptr的基本工作原理 - 当引用计数变为0时，指向的对象会被销毁。
- ❌ **重大遗漏**：题目明确问了两个问题（StrBlob和StrBlobPtr），但你只回答了第一个。
- ⚠️ **表述不精确**：说"shared_ptr成员counter"不准确，引用计数是shared_ptr内部管理的，不是直接可见的成员。
- ❌ **理解不足**：没有提到StrBlobPtr使用weak_ptr，而weak_ptr不影响引用计数。

**正确答案：**
```
1. 当StrBlob对象被销毁时：
   - StrBlob的析构函数被调用
   - 其data成员（shared_ptr<vector<string>>）被销毁
   - shared_ptr的引用计数减1
   - 如果引用计数变为0，则shared_ptr会自动释放其管理的vector<string>对象

2. 当StrBlobPtr对象被销毁时：
   - StrBlobPtr的析构函数被调用
   - 其wptr成员（weak_ptr<vector<string>>）被销毁
   - weak_ptr的销毁不会影响shared_ptr的引用计数
   - 因此，不会直接导致vector<string>对象的销毁
```

---