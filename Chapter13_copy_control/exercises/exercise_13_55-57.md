Exercise 13.55: Add an rvalue reference version of push_back to your StrBlob.
Answer:
太多了不写了

---

# 📘 练习题评价（13.56 & 13.57）

## 📋 总体概览

| 题目 | 得分 | 评价摘要 |
|------|------|----------|
| 13.56 | ⭐⭐⭐ (3/5) | 指出了无限循环，但解释有误，混淆了 const 与引用限定符的作用 |
| 13.57 | ⭐⭐ (2/5) | 概念错误，误解了右值调用的规则，答案中还有笔误 |

---

## 🎯 逐题详细评价

### 13.56 `sorted() const &` 实现分析

**原题：**  
```
Exercise 13.56: What would happen if we defined sorted as:

Foo Foo::sorted() const & {
    Foo ret(*this);
    return ret.sorted();
}
```

**你的答案：**  
```
错误， 在`return ret.sorted()`这里由于ret不是const无法调用到这个sorted()， 导致报错， 即使能调用到也是无限循环
```

**批改结果：** ⭐⭐⭐ (3/5)  
- **概念理解：** 部分正确，理解了会导致无限循环，但对成员函数的引用限定和常量性的理解有偏差。  
- **代码质量：** 不适用（未提供代码）。  
- **逻辑完整：** 部分正确，结论正确但推理有误。  
- **表达清晰：** 一般，表述不够准确。  

**详细分析：**  
- ✅ **正确之处：** 你意识到这段代码可能导致无限循环，这是对的。  
- ⚠️ **需要改进：**  
  - 原因分析有误：`ret` 是一个非常量左值，但 `sorted() const &` 是一个常量成员函数，它可以被非常量对象调用（常量性不影响调用资格）。实际上，`ret.sorted()` 会调用到同一个 `const &` 版本（如果没有其他重载），从而导致无限递归，而不是因为 `ret` 不是 const 而无法调用。  
  - 代码**不会报错**，编译是可以通过的，但运行时会无限递归（栈溢出）。  

**正确答案：**  
这段代码会形成无限递归。因为 `ret` 是 `*this` 的一个副本（非常量左值），调用 `ret.sorted()` 时，由于类中只有这一个 `const &` 版本的 `sorted`，编译器会选择它。每次调用都会创建新的副本并再次调用自身，导致无限循环。如果类中存在非 `const &` 版本或 `&&` 版本，则可能调用其他版本，但通常题目假设只有这一个定义。 
  

---

### 13.57 `sorted() const &` 实现分析

**原题：**  
```
Exercise 13.57: What if we defined sorted as:

Foo Foo::sorted() const & { return Foo(*this).sorted(); }
```

**你的答案：**  
```
错误， 在`return ret.sorted()`这里由于ret不是rvalue无法调用到这个sorted()， 导致报错， 即使能调用到也是无限循环
```

**批改结果：** ⭐⭐ (2/5)  
- **概念理解：** 错误，对右值和引用限定的理解不正确。  
- **代码质量：** 不适用。  
- **逻辑完整：** 错误，结论错误。  
- **表达清晰：** 较差，答案中出现了未定义的变量 `ret`，可能是笔误。  

**详细分析：**  
- ❌ 答案中出现了 `ret`，但代码中并没有 `ret` 变量，应该是笔误。  
- ❌ 主要错误：认为 `Foo(*this).sorted()` 会因为 `ret`（实际应是临时对象）不是右值而无法调用。事实上，`Foo(*this)` 创建的是一个**临时对象，它是右值**。如果类中定义了右值引用限定的 `sorted() &&` 版本，那么 `Foo(*this).sorted()` 会优先匹配该版本，从而避免递归，这是正确的实现方式。  
- ❌ 即使没有 `&&` 版本，临时对象也可以调用 `const &` 版本（因为 `const &` 能绑定到右值），此时也会无限递归，但代码仍能编译，不会报错。  
- ❌ 你的结论“导致报错”和“无限循环”都是错误的（在正确设计下不会无限循环，也不会报错）。  

**正确答案：**  
这段代码是正确的（前提是类中同时定义了右值引用限定的 `sorted() &&` 版本）。`Foo(*this)` 创建一个临时对象（右值），然后调用该临时对象的 `sorted()`。如果存在 `&&` 版本，它会执行原地排序并返回，避免递归。如果只有 `const &` 版本，则临时对象会调用该版本，同样导致无限递归，但这通常不是设计者的意图。因此，标准答案是：13.57 是一种避免递归的有效方法，因为它利用了右值重载。

---