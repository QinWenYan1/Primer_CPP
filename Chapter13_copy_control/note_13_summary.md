## C++ 拷贝控制章节知识表

本表汇总了C++中关于类拷贝控制（copy control）的核心概念、特殊成员函数及相关技术，涵盖章节总结和术语定义，便于快速查阅与复习。

| 类别 | 概念 | 定义 | 关键点 |
|------|------|------|--------|
| 📘 基础概念 | **copy control** | 控制类对象拷贝、移动、赋值和销毁的特殊成员函数。若类未显式声明，编译器会合成适当定义。 | • 包括拷贝构造函数、移动构造函数、拷贝赋值运算符、移动赋值运算符、析构函数<br>• 编译器合成操作遵循成员方式 |
| 📘 基础概念 | **copy initialization** | 使用等号 `=` 为新对象提供初始化器的初始化形式。也用于传值传递/返回、数组初始化、聚合类初始化。根据初始化器是左值还是右值，调用拷贝构造函数或移动构造函数。 | • 区别于直接初始化（使用括号）<br>• 可能调用移动构造函数（如果初始化器是右值） |
| 📘 基础概念 | **memberwise copy/assign** | 合成的拷贝/移动构造函数和赋值运算符的工作方式：依次处理每个非静态数据成员，对内置或复合类型直接拷贝/移动，对类类型成员调用其对应的拷贝/移动构造函数或赋值运算符。 | • 合成操作的行为是递归成员方式的<br>• 对于内置类型，直接拷贝/移动内存 |
| 📘 基础概念 | **deleted function** | 禁止使用的函数。通过在声明后加 `=delete` 来定义。常用于阻止编译器合成拷贝/移动操作。 | • 可用于禁止拷贝、移动等<br>• 如果类有数据成员不可拷贝/移动，则相应的合成函数会被隐式定义为删除 |
| 📘 基础概念 | **overloaded operator** | 重新定义运算符对类类型操作数含义的函数。本章展示了如何定义赋值运算符。 | • 运算符重载通常定义为成员函数或非成员函数<br>• 赋值运算符必须定义为成员函数 |
| 📘 基础概念 | **reference count** | 用于拷贝控制成员的编程技术，记录有多少对象共享同一状态。构造函数（非拷贝/移动）设计数为1，拷贝时递增，销毁时递减，赋值和析构检查计数归零并销毁资源。 | • 用于实现引用计数智能指针等<br>• 确保最后一个对象释放资源 |
| 🔧 特殊成员函数 | **copy constructor** | 用同类型对象拷贝初始化新对象的构造函数。隐式用于传值传递和返回。若未提供，编译器合成。 | • 第一个参数必须是自身类型的引用（通常为 `const` 左值引用）<br>• 如果类需要析构函数，通常也需要定义拷贝构造函数 |
| 🔧 特殊成员函数 | **copy-assignment operator** | 赋值运算符的版本，接受同类型对象。通常参数为 `const` 左值引用，返回自身对象的引用。若未显式提供，编译器合成。 | • 必须定义为成员函数<br>• 通常返回 `*this`<br>• 需要处理自赋值 |
| 🔧 特殊成员函数 | **move constructor** | 接受右值引用参数的构造函数。通常将参数的数据移动到新对象中。移动后，保证右值对象可安全析构。 | • 用于实现移动语义，避免不必要的拷贝<br>• 通常不分配新资源，而是接管指针 |
| 🔧 特殊成员函数 | **move-assignment operator** | 接受右值引用参数的赋值运算符。将右侧操作数的数据移动到左侧。赋值后，右侧操作数可安全析构。 | • 必须处理自赋值（但移动自赋值通常不会发生）<br>• 常与移动构造函数一起实现 |
| 🔧 特殊成员函数 | **destructor** | 对象离开作用域或被 `delete` 时执行清理的特殊成员函数。编译器自动销毁每个数据成员：类类型成员调用其析构函数，内置/复合类型成员不做操作（指针成员指向的对象不会自动 `delete`）。 | • 无参数，无返回值<br>• 如果类需要析构函数（如管理资源），则几乎肯定也需要定义拷贝/移动操作<br>• 合成的析构函数函数体为空，但之后会成员析构 |
| 🛠️ 操作技术 | **copy and swap** | 编写赋值运算符的技术：先拷贝右侧操作数，然后调用 `swap` 交换拷贝与左侧操作数。 | • 自动处理自赋值，异常安全<br>• 通常需要定义 `swap` 函数 |
| 🛠️ 操作技术 | **move** | 标准库函数，用于将左值绑定到右值引用。调用 `move` 隐式承诺除了销毁或重新赋值外不再使用原对象。 | • `std::move` 本质上是一个类型转换<br>• 使用后原对象处于有效但未指定状态 |
| 🛠️ 操作技术 | **move iterator** | 迭代器适配器，解引用时生成右值引用。 | • 用于将范围中的元素移动而不是拷贝<br>• 通过 `std::make_move_iterator` 创建 |
| ⚙️ 引用类型 | **lvalue reference** | 可绑定到左值的引用。用 `&` 声明。 | • 不能绑定到右值（`const` 左值引用可绑定到右值，但那是特例）<br>• 用于传递左值 |
| ⚙️ 引用类型 | **rvalue reference** | 可绑定到即将销毁的对象的引用（右值）。用 `&&` 声明。 | • 用于实现移动语义和完美转发<br>• 可以绑定到临时对象 |
| ⚙️ 引用类型 | **reference qualifier** | 用于指明非静态成员函数可在左值或右值上调用的限定符。`&` 或 `&&` 放在参数列表或 `const` 之后。`&` 限定的函数只能由左值对象调用，`&&` 限定的只能由右值对象调用。 | • 用于控制成员函数在左值/右值上的可调用性<br>• 例如，可以在右值上调用移动版本的成员函数 |
| 🔄 合成操作 | **synthesized assignment operator** | 编译器为未显式定义赋值运算符的类生成的拷贝或移动赋值运算符版本。除非定义为删除，否则合成版本会按成员赋值/移动右侧操作数到左侧。 | • 如果类有不可拷贝/移动的成员，则对应合成操作被定义为删除<br>• 合成拷贝赋值运算符执行成员拷贝赋值，合成移动赋值运算符执行成员移动赋值 |
| 🔄 合成操作 | **synthesized copy/move constructor** | 编译器为未显式定义构造函数的类生成的拷贝或移动构造函数版本。除非定义为删除，否则合成版本按成员初始化新对象。 | • 合成拷贝构造函数执行成员拷贝初始化，合成移动构造函数执行成员移动初始化<br>• 如果成员不可拷贝/移动，则相应合成函数为删除 |
| 🔄 合成操作 | **synthesized destructor** | 编译器为未显式定义析构函数的类生成的析构函数版本。合成析构函数函数体为空。 | • 函数体为空，但编译器会隐式销毁每个成员（在函数体之后）<br>• 如果类需要释放资源，必须自定义析构函数 |
