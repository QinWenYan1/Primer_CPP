# 📘 3.5.6 多维数组 (Multidimensional Arrays)

> 基于《C++ Primer》第五版。C++ 中的多维数组本质上是**数组的数组**，常用于表示表格/矩阵数据。

---

## 🧠 本节核心概念（目录）

* 多维数组的本质与声明
* 初始化（完整、部分、值初始化）
* 下标访问与“行”的引用
* 遍历（下标；范围 for 的引用要求）
* 指针与多维数组（衰变、指向数组的指针）
* 避免指针遍历的复杂性 - 使用 `auto` (C++11)
* 用 `std::begin/std::end` 进行指针遍历
* 作为函数形参（必须写死除第一维外的尺寸）

---

## ✅ 多维数组的本质与声明

多维数组是**数组的数组**。以二维为例，`int ia[3][4];` 表示“含 3 个元素的一维数组”，每个元素本身又是“含 4 个 `int` 的数组”。内存为**行主序（row-major）**：同一行元素在内存中连续。

```cpp
int ia[3][4];        // 3 行 × 4 列，未初始化
int arr[10][20][30]; // 三维数组
```

---

## ✅ 初始化（完整、部分、值初始化）

支持提供初始器，嵌套花括号。未提供的元素进行**默认值初始化**（内置类型）。

```cpp
int ia[3][4] = {
    {0, 1, 2, 3},
    {4, 5, 6, 7},
    {8, 9,10,11}
};

int ib[3][4] = { {1}, {2}, {3} };
// ib[0][0]=1, ib[1][0]=2, ib[2][0]=3，其余元素均为 0

int ic[3][4] = { 0, 3, 6, 9 }; 
// 只给首行，余下两行元素值初始化为 0
```

---

## ✅ 下标访问与“行”的引用

和普通数组一样，多维数组也通过多个下标访问元素：
- **下标数量 = 维度数**：就能直接取到一个具体元素
- **下标数量 < 维度数**：如果只给一部分下标，没有覆盖所有维度，就得到的是内层的数组

```cpp
ia[2][3] = 99;            // 修改第 3 行第 4 列
int (&row)[4] = ia[1];        // row 是 “引用到含 4 个 int 的数组”
row[0] = 42;              // 等价于 ia[1][0] = 42
```

---

## ✅ 遍历

### 📝 下标遍历
我们可用嵌套 `for` 循环去处理多维数组:

```cpp
// 下标遍历
for (size_t i = 0; i < 3; ++i)
    for (size_t j = 0; j < 4; ++j)
        std::cout << ia[i][j] << ' ';
```
- 外层 for 循环遍历每个以数组为元素的元素
- 内层则是遍历每个内部数组里面的元素
### 📝 for-range 遍历
我们可以通过使用 `for` range 去简化我们的嵌套遍历:


```cpp
// 范围 for（外层必须引用）
for (const auto &row : ia) {   // row: 引用到“含 4 个 int 的数组”
    for (auto &col : row)       // 最内层按需用值或引用
        col = 1;
}
```
**使用 `&` 引用符号**:
    
- 当我们在使用 range for 循环一样，如果需要修改数组内元素，一定要带上 `&` 
- 更深沉的原因是，如果外层的循环没有使用 `&`， **被遍历的数组元素会直接衰变为指针**(也就是例子里的`row`)， 导致内部 `for` 循环直接报错

**⚠️ 警告**：
范围 for 的**外层变量必须是引用**，否则数组会衰变为指针，内层遍历将失去数组语义。

---

## ✅ 指针与多维数组（衰变、指向数组的指针）

- 当我们使用多维数组的名字时， 其会**自动转换**为指向这个多维数组的第一个元素的**指针**
- 在表达式中，`ia` 衰变为“指向首行的指针”，类型为 `int (*)[4]`。区分**指针数组** vs **指向数组的指针**。

```cpp
int ia[3][4]; 
int (*p)[4] = ia;  // p 指向“含 4 个 int 的数组”（即一行）
p = &ia[2];        // 指向最后一行
```
**⚠️ 提示**：`p + 1` 会跨过**整行**（跳过 4 个 `int`），非单元素。

```cpp
int *ip[4];        // ip 是“含 4 个指向 int 的指针”的数组（不同概念）
int (*ip4)[4];     // ip4 是“指向含 4 个 int 的数组”的指针（与 p 同类）
```
**⚠️ 提示**：括号在声明中非常重要 ！没有括号，下标运算符优先级最高

---
## ✅ 避免指针遍历的复杂性 - 使用 `auto` (C++11)
C++11的特性让我们可以使用 `auto`, `decltype` 来避免在指针遍历时需要声明指针类型的复杂性

```cpp
int ia[3][4] = {
    {0, 1, 2, 3},
    {4, 5, 6, 7},
    {8, 9, 10, 11}
};

// 外层 p 指向一行（即 int[4]）
// 内层 q 指向单个元素
for (auto p = ia; p != ia + 3; ++p) {
    for (auto q = *p; q != *p + 4; ++q) {
        std::cout << *q << " ";
    }
    std::cout << std::endl;
}
```




- `auto p = ia; → p` 被推导为 `int (*)[4]`，即指向长度为 4 的数组的指针

- `++p` 会让 `p` 移动到下一行

- `*p` 解引用后是 `int[4]`，在表达式中退化为 `int*`，所以 `q` 被推导为 `int*`

- `q != *p + 4` 表示在该行内遍历 4 个元素

- `*q` 解引用得到单个 `int` 元素

---

## ✅ 用 `std::begin/std::end` 进行指针遍历

我们还可以用 `std::begin/std::end` 来再简化我们的嵌套循环，可以获取**行指针**与**行内指针**，更安全直观。

```cpp
for (auto p = std::begin(ia); p != std::end(ia); ++p) {     // p: int (*)[4]
    for (auto q = std::begin(*p); q != std::end(*p); ++q)   // q: int*
        std::cout << *q << ' ';
    std::cout << '\n';
}
```

---

## ✅ 类型别名简化指针遍历

- 在二维数组 `int ia[3][4];` 中，每一行的类型是 `int[4]`
- 如果我们想写一个指针 p 指向一行（即“含 4 个 int 的数组”），就得写：`int (*p)[4];` 这种写法复杂、可读性差
- 解决办法：用**类型别名**（using 或 typedef）给 int[4] 起个名字

```cpp
using int_array = int[4];   // C++11 新写法，别名 int_array 代表 "int[4]"
// typedef int int_array[4]; // 等价的旧写法

for (int_array *p = ia; p != ia + 3; ++p) {   // p 是指向 int[4] 的指针
    for (int *q = *p; q != *p + 4; ++q) {     // q 是指向 int 的指针
        cout << *q << ' ';
    }
    cout << endl;
}
```
---

👌 好的，我帮你优化一下 **小结** 和 **考试速记版**，让它们更精炼、体系更清晰，起到提纲挈领的效果。

---

## 🔑 小结（优化版）

1. **本质**：多维数组是“数组的数组”，在内存中按 **行主序（row-major）** 连续存放。
2. **初始化**：支持完整、部分、值初始化，未显式提供的元素进行值初始化。
3. **访问**：

   * 下标个数 = 维度数 → 具体元素
   * 下标个数 < 维度数 → 内层数组
   * 可绑定“行引用”：`int (&row)[N] = arr[i];`
4. **遍历**：

   * 下标嵌套 for 循环
   * 范围 for：外层必须是 **引用**，避免数组衰变为指针
5. **指针**：

   * `int (*)[N]` → 指向“一行”的指针
   * `p+1` 跨过整行
   * 区分 **指针数组 (`int *ip[N]`)** vs **指向数组的指针 (`int (*p)[N]`)**
6. **简化技巧**：

   * 使用 `auto` 推导指针类型
   * 使用 `std::begin/std::end` 获取范围
   * 用 `using`/`typedef` 为一行定义类型别名，提升可读性
7. **函数形参**：除第一维外，其他维度必须显式写出，才能正确计算偏移。

---

## 📌 考试速记版（优化版）

**口诀**：

* **本质**：多维数组 = 数组的数组，行主序存储。
* **访问**：下标全写到 → 元素；少写 → 内层数组。
* **遍历**：外层 for-range 要写引用；下标法照旧。
* **指针**：`int (*)[N]` 指一行；`p+1` 跨整行。
* **函数**：形参列数要写死。
* **易混**：指针数组 ≠ 指向数组的指针。
* **技巧**：用 `auto`、`begin/end`、`using` 简化声明与遍历。


