# 📘 3.3 Library vector Type

> 本章笔记基于《C++ Primer》第五版整理，详细介绍C++标准库中的vector容器类型，包括其作为类模板的特性、多种初始化方式、动态增长机制以及各种操作方法。

---

## 🧠 本章核心概念

- ✯ **vector的本质与特性**
  - 可变大小的对象序列容器
  - 所有元素类型必须相同
  - 通过索引高效访问元素
  - 标准库保证的高效动态增长

- ✯ **类模板机制**
  - vector是类模板而非类型
  - 必须指定元素类型来实例化
  - 编译器根据类型参数生成特定类
  - 支持嵌套使用（vector of vectors）

- ✯ **初始化策略**
  - 默认初始化创建空vector（最常用）
  - 拷贝初始化从已有vector复制
  - 列表初始化直接指定元素值
  - 值初始化创建指定数量的默认元素
  - 括号vs花括号的重要语义区别

- ✯ **动态增长模型**
  - push_back高效添加元素
  - 从空vector开始逐步增长
  - 与传统数组的根本性区别
  - 对循环编程的影响

- ✯ **操作与访问**
  - 下标运算符的未检查特性
  - size和empty查询操作
  - 比较和赋值操作
  - range for遍历机制
  - 索引计算与边界安全

---

## ✅ vector基础概念

### 📝 什么是vector？

**核心定义**：
- vector是**对象的集合**，所有对象都具有相同类型
- 集合中的每个对象都有一个关联的**索引**，用于访问该对象
- vector经常被称为**容器**（container），因为它"包含"其他对象
- 更多容器内容将在Part II中详细讨论

**使用前的准备**：
```cpp
#include <vector>
using std::vector;
```

**设计理念**：
- vector提供了**动态数组**的功能
- 自动管理内存分配和释放
- 支持高效的尾部插入操作
- 提供随机访问能力

---

## ✅ vector作为类模板

### 📝 模板的深入理解

**类模板的本质**：
- vector是一个**类模板**（class template），不是类型本身
- C++支持两种模板：类模板和函数模板
- 编写模板需要相当深入的C++理解（第16章详述）

**模板工作机制**：
- 模板是**编译器的指令**，告诉编译器如何生成类或函数
- 编译器用模板创建类或函数的过程叫做**实例化**（instantiation）
- 使用模板时，我们指定要实例化的具体类型
- 编译器根据我们的指定生成相应的代码

### 📝 vector的类型指定

**指定元素类型的语法**：
```cpp
vector<T> name;  // T是元素类型，name是变量名
```

**关键规则**：
- 类型信息必须放在**尖括号**内
- 尖括号紧跟在模板名称后
- 这种方式对所有类模板都相同

**实例化示例**：
```cpp
vector<int> ivec;              // ivec保存int类型的对象
vector<Sales_item> Sales_vec;  // 保存Sales_item对象
vector<vector<string>> file;   // vector的元素是vector<string>
```

**编译器的实例化过程**：
编译器看到这些声明后，会从vector模板生成三种不同的类型：
1. `vector<int>` - 存储整数的vector类
2. `vector<Sales_item>` - 存储Sales_item对象的vector类
3. `vector<vector<string>>` - 存储字符串vector的vector类

### 📝 重要限制和注意事项

📌 **Note - vector不是类型**：
```cpp
vector v;           // 错误：vector是模板，不是类型
vector<int> v;      // 正确：vector<int>是类型
```

**可存储类型的限制**：
- ✅ 可以存储：
  - 所有内置类型（int, double, char等）
  - 大多数类类型（string, Sales_item等）
  - 其他vector类型（嵌套vector）
  
- ❌ 不能存储：
  - 引用（因为引用不是对象）
  - 某些特殊的不可复制类型

**嵌套vector的特殊情况**：
```cpp
vector<vector<int>> matrix;    // C++11正确写法
vector<vector<int> > matrix;   // 旧版本C++需要空格
```

💻 **C++版本差异**：
- C++11之前，连续的`>>`会被解析为右移运算符
- 必须在两个`>`之间加空格：`vector<vector<int> >`
- 现代编译器已经解决了这个问题

⚠️ **Warning**：
某些老旧编译器可能仍需要旧式声明格式。

---

## ✅ 3.3.1 定义和初始化vectors

### 📝 初始化方式详解

**vector模板的控制机制**：
- vector模板定义了多种初始化方式
- 每种方式适用于不同的场景
- 选择正确的初始化方式可以提高代码效率和可读性

### 📋 初始化方式完整列表

| 声明方式 | 说明 | 使用场景 |
|---------|------|---------|
| `vector<T> v1` | 默认初始化，v1为空 | 最常用，后续动态添加元素 |
| `vector<T> v2(v1)` | 拷贝构造，v2是v1的副本 | 需要复制已有vector |
| `vector<T> v2 = v1` | 拷贝初始化，等同于v2(v1) | 同上，语法略有不同 |
| `vector<T> v3(n, val)` | n个值为val的元素 | 需要相同初始值 |
| `vector<T> v4(n)` | n个值初始化的元素 | 需要默认值元素 |
| `vector<T> v5{a,b,c...}` | 列表初始化 | 知道所有初始值 |
| `vector<T> v5 = {a,b,c...}` | 列表初始化的另一种形式 | 同上 |

### 📝 默认初始化 - 最常用方式

**创建空vector**：
```cpp
vector<string> svec;  // 默认初始化；svec没有元素
```
- 不需要预先知道元素数量
- 支持高效的动态增长：可以在运行态下进行拷贝，添加元素等操作


### 📝 拷贝初始化

**从另一个vector复制**：
```cpp
vector<int> ivec;              // 初始为空
// ... 给ivec添加一些值
vector<int> ivec2(ivec);       // 拷贝构造：复制所有元素
vector<int> ivec3 = ivec;      // 拷贝初始化：同样复制所有元素
vector<string> svec(ivec2);    // 错误：类型必须匹配
```

**关键要求**：
- 源 `vector` 和目标 `vector` 必须是**完全相同的类型**
- 包括元素类型必须完全一致
- 执行深拷贝，每个元素都被复制

### 📝 列表初始化（C++11）

**直接指定初始元素**：
```cpp
vector<string> articles = {"a", "an", "the"};
vector<int> scores = {98, 85, 76, 92, 88};
```

**特点和优势**：
- 最直观的初始化方式
- 适合已知所有初始值的情况
- 类型安全，编译器会检查每个元素

**初始化形式的限制**：
```cpp
vector<string> v1{"a", "an", "the"};  // ✅ 列表初始化
vector<string> v2("a", "an", "the");  // ❌ 错误：不能用括号
```

**重要规则**：
* 用 `=` 做**拷贝初始化**时 **只能有一个初始化器**，不能一次给多个值。
* **类内成员默认初值**只能写成 `= expr` 或 `{expr}`，**不能**用 `(...)`。
* 想一次给出**多个元素**，必须用**花括号列表初始化** `{...}`；**圆括号不是列表**。

### 📝 创建指定数量的元素的初始化（直接初始化）

**指定数量和初始值**：
```cpp
vector<int> ivec(10, -1);       // 10个值为-1的int
vector<string> svec(10, "hi!");  // 10个值为"hi!"的string
```

**使用场景**：
- 需要固定数量的相同元素
- 作为数组的替代品
- 预分配空间以提高性能

### 📝 值初始化

**只指定大小的情况**：
```cpp
vector<int> ivec(10);     // 10个元素，每个初始化为 0
vector<string> svec(10);  // 10个元素，每个都是空string
```

**值初始化规则**：
- 库自动创建**用值初始化元素的初始化器** 去初始化每个 `vector` 元素, 初始化值取决于元素类别
- **内置类型**：初始化为0（int）、0.0（double）、false（bool）等
- **类类型**：调用默认构造函数

**两个重要限制**：

1. **某些类需要显式初始化器，因为某些类没有提供默认初始化**：
```cpp
// 假设NoDefault类没有默认构造函数
vector<NoDefault> v1(10);        // 错误：无法默认初始化
vector<NoDefault> v2(10, init);  // 正确：提供初始化器
```

2. **必须使用直接初始化**：
```cpp
vector<int> vi = 10;    // 错误：不能用拷贝初始化指定大小
vector<int> vi(10);     // 正确：直接初始化
```

### 📝 🔑 括号vs花括号 - 关键区别

**初始化语义的具体含义可以在花括号或括号的使用中体现**：

**括号`()` - 构造语义**：
- 参数用来**构造**对象
- 指定vector的结构（大小、初始值）
- 调用构造函数

**花括号`{}` - 列表初始化优先**：
- 优先尝试**列表初始化**
- 如果可能，将内容作为元素列表
- 只有列表初始化不可能时才退化为构造

**关键示例对比**：
```cpp
// 处理int类型
vector<int> v1(10);      // 10个值为0的元素（构造）
vector<int> v2{10};      // 1个值为10的元素（列表初始化）
vector<int> v3(10, 1);   // 10个值为1的元素（构造）
vector<int> v4{10, 1};   // 2个元素：10和1（列表初始化）

// 处理string类型
vector<string> v5{"hi"};      // 1个元素"hi"（列表初始化）
vector<string> v6("hi");      // 错误：不能用字符串构造
vector<string> v7{10};        // 10个空string（退化为构造）
vector<string> v8{10, "hi"};  // 10个"hi"（退化为构造）
```

**判断规则**：
1. 使用花括号时，编译器首先尝试列表初始化
2. 检查花括号内的值能否作为元素类型
3. 如果可以→ **列表初始化**
4. 如果不可以→ **尝试其他构造方式**

**为什么v7和v8退化为构造**：
- `vector<string>`的列表初始化需要string类型的值
- 整数10不能初始化string
- 因此编译器将`{10}`解释为构造参数
- 同理`{10, "hi"}`被解释为大小和初始值

---

## ✅ 3.3.2 向vector添加元素

### 📝 动态增长的设计哲学

**为什么需要动态添加**：

**直接初始化的局限性**：
- ❌ 需要创建时知道需要多少元素
- ❌ 需要知道元素的具体值
- ❌ 大量不同的初始值难以枚举
- ❌ 元素需要通过计算或输入获得

**动态增长的优势**：
- ✅ 按需分配内存
- ✅ 不需要预估大小
- ✅ 更灵活的编程模式：可以在运行态时添加元素
- ✅ 标准保证的高效实现

### 📝 push_back - 核心操作

**基本语法**：
```cpp
vector.push_back(value);  // 将value添加到vector末尾
```

**工作机制**：
- 在vector的**末尾**添加新元素
- 必要时自动扩展容量
- 保持元素的顺序
- 平均时间复杂度O(1)

**示例1：生成序列**：
```cpp
vector<int> v2;                  // 空vector
for (int i = 0; i != 100; ++i)
    v2.push_back(i);             // 追加0到99
// 循环结束时，v2有100个元素
```



**示例2：读取未知输入**：
```cpp
string word;
vector<string> text;              // 空vector
while (cin >> word) {
    text.push_back(word);         // 逐个添加单词
}
// text现在包含所有输入的单词
```

### 🚀 关键概念：vectors高效增长

**标准库的保证**：
> 标准要求vector实现能够**高效地**在运行时添加元素，因此没有必要去定义 `vector` 的具体大小 

**与传统思维的对比**：

| 传统数组思维（C/Java） | 现代vector思维（C++） |
|----------------------|---------------------|
| 预先确定大小 | 从空开始动态增长 |
| 固定容量 | 自动扩展容量 |
| 手动内存管理 | 自动内存管理 |
| 可能浪费空间 | 按需分配 |



### 📝 编程含义和注意事项

**新的编程义务**：
> 我们必须确保编写的任何循环即使循环改变vector的大小也是正确的

这段话的意思是两点：

1. **`vector` 动态扩容很方便**，但这也要求你写循环时要考虑**循环过程中大小可能会变**，否则就会出错（例如死循环或越界）。

2. **用 range-for 遍历时，循环体里不能改变正在遍历的序列大小**（不能 `push_back`、`insert`、`erase`）。
   原因：range-for 在开始时会取得一对迭代器 `begin/end` 的“快照”。

   * 如果你 **追加/删除** 元素，可能会：

     * 因为容量不足触发**扩容**导致**重分配内存** → 之前保存的迭代器全部失效，行为未定义；
     * 即便不重分配，**`end` 也不会更新**→ 新元素不会被遍历到，或删除导致越界。

**反例**

```cpp
std::vector<int> v = {1,2,3};
for (auto& x : v) {
    v.push_back(0);   // ❌ range-for 中修改大小：UB 或至少遍历不到新元素
}

std::vector<int> v(3);
for (size_t i = 0; i < v.size(); ++i) { // ❌ v.size() 在变，可能永不结束
    v.push_back(i);
}
```

⚠️ **Warning**：
**range-for 只读/改值可以，改“大小”不行**；需要增删就用索引/普通迭代器并小心处理迭代器失效与循环边界。

---

## ✅ 3.3.3 其他vector操作

### 📝 基本操作概览

**与string的相似性**：
- vector的许多操作与string类似
- 设计理念保持一致
- 便于学习和使用

### 📋 vector操作完整列表

| 操作 | 返回值/效果 | 说明 |
|------|------------|------|
| `v.empty()` | bool | 如果v为空返回true |
| `v.size()` | size_type | 返回元素数量 |
| `v.push_back(t)` | void | 在末尾添加元素t |
| `v[n]` | 元素引用 | 返回位置n的元素 |
| `v1 = v2` | v1引用 | 用v2的副本替换v1 |
| `v1 = {a,b,c...}` | v1引用 | 用列表元素替换v1 |
| `v1 == v2` | bool | 元素数量和值都相同 |
| `v1 != v2` | bool | 存在不同 |
| `<, <=, >, >=` | bool | 字典序比较 |

### 📝 访问vector的元素

**使用range for遍历**：
```cpp
vector<int> v{1,2,3,4,5,6,7,8,9};

// 修改元素（使用引用）
for (auto &i : v)      
    i *= i;            // 平方每个元素

// 只读访问（值传递）
for (auto i : v)       
    cout << i << " ";  // 输出：1 4 9 16 25 36 49 64 81
```

**关键点**：
- 使用`&`创建引用以修改元素
- 不使用`&`则是值拷贝，不能修改原元素
- `auto`自动推导元素类型

### 📝 size和empty成员

**empty()函数**：
```cpp
vector<int> v;
if (v.empty()) {
    cout << "Vector is empty" << endl;
}
```

**size()函数**：
```cpp
vector<int> v{1, 2, 3};
cout << "Size: " << v.size() << endl;  // 输出：Size: 3
```

**size_type的使用**：
```cpp
vector<int>::size_type count = v.size();  // 正确
// vector::size_type count;                // 错误：缺少元素类型
```

📌 **Note**：
vector类型**总是包含其元素类型**，因此必须写成`vector<T>::size_type`。

### 📝 比较操作

**相等性比较**：
```cpp
vector<int> v1{1, 2, 3};
vector<int> v2{1, 2, 3};
vector<int> v3{1, 2};

v1 == v2;  // true：元素完全相同
v1 == v3;  // false：元素数量不同
```

**字典序比较**：
```cpp
vector<int> v1{1, 2, 3};
vector<int> v2{1, 2, 4};
vector<int> v3{1, 2};

v1 < v2;   // true：第3个元素3 < 4
v3 < v1;   // true：v3元素少但相同部分相等
```

**比较规则**：
1. 逐元素比较
2. 第一个不同元素决定大小关系
3. 若所有共同元素相等，短vector更小

**类型要求**：
```cpp
vector<string> sv1{"hello"}, sv2{"world"};
sv1 < sv2;  // OK：string支持比较

vector<Sales_item> sales1, sales2;
// sales1 < sales2;  // 错误：Sales_item不支持<运算符
```

### 📝 计算vector索引

**使用下标运算符**：
```cpp
vector<int> v{1, 2, 3, 4, 5};
v[0];      // 第一个元素：1
v[4];      // 最后一个元素：5
v[v.size() - 1];  // 最后一个元素的通用写法
```

* `vector` 下标从 **0** 开始，先算索引再取值也 OK（随机访问）。
* 下标类型用 **`vector<T>::size_type`**（无符号）；推荐 `auto i = v.size();`，避免与 `int` 混用。
* `v[n]` 返回**引用**：非常量 `vector` 得到 `T&` 可修改；`const vector` 得到 `const T&` 只读。
* `[]` **不检查越界、不会新增元素**；范围必须在 `0 .. v.size()-1`。需要检查用 `v.at(n)`。


### 📝 实例：成绩聚类统计

**问题描述**：
统计0-100分的成绩分布，按10分一组聚类。

**实现方案**：
```cpp
// 11个计数器：0-9, 10-19, ..., 90-99, 100
vector<unsigned> scores(11, 0);  // 全部初始化为0
unsigned grade;

while (cin >> grade) {
    if (grade <= 100)             // 验证输入有效性
        ++scores[grade/10];       // 递增对应的计数器
}

// 输出结果
for (auto count : scores) {
    cout << count << " ";
}
```

**工作原理分析**：
1. **索引计算**：`grade/10`利用整数除法截断
   - 0-9 → 0
   - 10-19 → 1
   - 90-99 → 9
   - 100 → 10

2. **边界检查**：`if (grade <= 100)`确保索引有效

3. **递增操作**：`++scores[grade/10]`等价于：
```cpp
auto ind = grade/10;
scores[ind] = scores[ind] + 1;
```

### 📝 下标操作的关键警告

⚠️ **下标不添加元素**：

```cpp
// ❌ 常见错误
vector<int> ivec;  // 空vector
for (decltype(ivec.size()) ix = 0; ix != 10; ++ix)
    ivec[ix] = ix;  // 错误：ivec没有元素！

// ✅ 正确做法
vector<int> ivec;
for (decltype(ivec.size()) ix = 0; ix != 10; ++ix)
    ivec.push_back(ix);  // 正确：添加新元素
```

**关键理解**：
- 下标运算符只能访问**已存在**的元素
- 不会创建新元素
- 必须使用push_back添加元素

### 🔴 只下标存在的元素！

**未定义行为示例**：
```cpp
vector<int> ivec;      // 空vector
cout << ivec[0];       // 未定义行为！

vector<int> ivec2(10); // 10个元素
cout << ivec2[10];     // 未定义行为！索引0-9有效
```

**缓冲区溢出**：
- 下标越界是**缓冲区溢出**的典型原因
- PC和应用程序中最常见的安全漏洞 - `buffer overflow`
- 编译器通常不会检测这种错误
- 运行时结果不可预测

**安全建议**：
```cpp
// 访问前总是检查
if (!v.empty() && index < v.size()) {
    // 安全访问v[index]
}

// 或使用at()方法（会检查边界）
try {
    v.at(index);  // 越界会抛出异常
} catch (out_of_range& e) {
    // 处理越界
}
```

💡 **Tip**：
避免下标越界的最好方法是尽可能使用 **range for** 循环。

---

## 🍃 小结

### 📚 核心知识体系

**vector的设计理念**：
- **动态数组**：自动管理内存，按需增长
- **类型安全**：通过模板机制保证类型一致性
- **高效实现**：标准库保证的性能优化
- **统一接口**：与其他容器保持一致的操作接口

**三个关键特性**：

1. **模板实例化**：
   - vector是类模板，需要指定元素类型
   - 编译器根据类型参数生成具体的类
   - 支持几乎所有类型（除了引用）

2. **动态增长**：
   - 从空vector开始是最佳实践
   - push_back高效添加元素
   - 自动内存管理，无需手动分配

3. **安全访问**：
   - 下标操作不检查边界
   - 必须确保索引在有效范围内
   - range for提供更安全的遍历方式

### ⚡ 关键概念精要

**初始化选择策略**：
- **默认初始化**（空vector）：最常用，适合动态添加
- **列表初始化**（花括号）：已知所有初始值
- **直接初始化**（指定大小和数量）：需要默认值元素
- **拷贝初始化**：复制已有vector

**括号vs花括号的本质区别**：
- `()`括号 → **构造**语义（大小、初始值）
- `{}`花括号 → **列表初始化**优先（元素列表）
- 理解这个区别对正确使用vector至关重要

**下标操作的三个要点**：
1. 只能访问已存在的元素
2. 不会添加新元素
3. 越界访问是未定义行为

### 🛡️ 实践指导原则

**最佳实践清单**：

✅ **DO（推荐做法）**：
- 从空vector开始，使用push_back添加元素
- 使用range for安全遍历所有元素
- 访问元素前检查vector是否为空
- 使用auto推导复杂类型
- 理解并正确使用括号和花括号

❌ **DON'T（避免做法）**：
- 不要预分配大小除非确实需要
- 不要在range for中修改容器大小
- 不要假设下标会添加元素
- 不要访问越界元素
- 不要忽视类型匹配要求

**性能考虑**：
- vector的动态增长已经高度优化
- 通常不需要手动优化容量
- 信任标准库的实现
- 专注于算法而非底层细节

### 🚨 常见陷阱总结

**五大易错点**：

1. **混淆vector和数组思维**：
   - 错误：预分配固定大小
   - 正确：动态增长

2. **下标越界**：
   - 错误：`v[v.size()]`
   - 正确：`v[v.size()-1]`

3. **误用下标添加元素**：
   - 错误：`v[i] = value`（v为空）
   - 正确：`v.push_back(value)`

4. **range for中修改大小**：
   - 错误：在循环中push_back
   - 正确：使用索引循环或其他方法

5. **括号花括号混淆**：
   - `vector<int> v(10)` → 10个0
   - `vector<int> v{10}` → 1个10

| 特性 | vector | 传统数组 |
|-----|--------|---------|
| 大小 | 动态可变 | 固定不变 |
| 内存管理 | 自动 | 手动 |
| 边界检查 | 可选(at方法) | 无 |
| 初始化 | 灵活多样 | 受限 |
| 性能 | 轻微开销但优化良好 | 无开销 |
| 类型安全 | 模板保证 | 较弱 |
| STL算法 | 完全支持 | 部分支持 |

### 📊 使用决策树

```
需要存储多个相同类型的对象？
├─ 是 → 大小固定且性能关键？
│   ├─ 是 → 考虑数组
│   └─ 否 → 使用vector ✓
└─ 否 → 考虑其他容器
```

### 💡 核心理念总结

**vector代表了现代C++的设计哲学**：
1. **零开销抽象** - 提供高级功能但性能接近底层
2. **RAII原则** - 自动资源管理，无需手动释放
3. **类型安全** - 编译时类型检查，减少错误
4. **标准化接口** - 与其他STL容器一致
5. **灵活性** - 适应各种使用场景

**记住最重要的三句话**：
1. 📌 vector是模板不是类型，必须指定元素类型
2. 📌 从空vector开始用push_back添加是最佳实践  
3. 📌 下标操作不添加元素且不检查边界

这些知识构成了使用vector的坚实基础，为后续学习迭代器、算法和更高级的容器操作奠定了基础。vector不仅是一个容器，更是理解现代C++编程范式的关键入口。