# 📘 3.4 迭代器 (Iterators)

> 本章笔记基于《C++ Primer》第五版整理，详细介绍迭代器这一更通用的容器访问机制，包括其概念、操作、类型以及算术运算等核心内容。

---

## 🧠 本章核心概念

- ✯ **迭代器的本质**
  - 提供对容器元素的间接访问
  - 类似指针但更通用的抽象
  - 所有标准库容器都支持迭代器
  - 统一的容器访问接口

- ✯ **迭代器vs下标访问**
  - 下标运算符只有少数容器支持
  - 迭代器是更通用的访问方式
  - string虽然不是容器类型，但支持容器操作
  - 为泛型编程奠定基础

- ✯ **迭代器的状态**
  - 有效迭代器：指向元素或end位置
  - 无效迭代器：其他所有情况
  - begin和end成员函数
  - off-the-end迭代器概念

- ✯ **迭代器类型系统**
  - iterator和const_iterator类型
  - 根据容器const性质自动选择
  - cbegin/cend强制返回const_iterator
  - 箭头运算符简化成员访问

---

## ✅ 迭代器基础概念

### 📝 什么是迭代器？

**核心定义**：
- 迭代器是一种**更通用的机制**，用于访问string或vector中的元素
- 类似**指针**，提供对对象的间接访问
- 在迭代器情况下，该对象是容器中的元素或string中的字符
- 有效迭代器只可能指向容器中某个元素，或指向“尾后位置”（紧挨最后一个元素之后、仅作边界标记且**不可解引用**的 `end` 位置）；除此之外的任何位置（越界或已失效）都无效。


**设计优势**：
- 📍 **通用性**：所有标准库容器都有迭代器
- 📍 **一致性**：提供统一的访问接口  
- 📍 **扩展性**：支持未来的容器类型
- 📍 **泛型编程**：为算法提供统一抽象

**与下标访问的对比**：

| 特性 | 下标运算符 | 迭代器 |
|------|-----------|--------|
| 支持容器 | vector、string等少数 | 所有标准库容器 |
| 通用性 | 有限 | 通用 |
| 泛型编程 | 不适用 | 完全支持 |
| 随机访问 | 直接 | 取决于迭代器类型 |

---

## ✅ 3.4.1 使用迭代器

### 📝 获取迭代器

**基本语法**：
```cpp
// 不使用取地址符&来获取迭代器
// 而是使用begin和end成员函数
auto b = v.begin(), e = v.end(); // b和e类型相同
```

**关键成员函数**：
- **`begin()`**：返回指向**第一个元素**的迭代器（如果有的话）
- **`end()`**：返回指向**最后一个元素之后**位置的迭代器

### 📝 🔑 off-the-end 迭代器概念

**end()迭代器的特殊性**：
- 指向本容器的尾后位置
- 指向一个**不存在的元素** "off the end"
- 用作**标记**，表示已处理完所有元素
- 通常称为**off-the-end迭代器**或**end迭代器**
- 如果容器为空，begin返回的迭代器与end相同
```cpp
// 空容器的特殊情况
vector<int> empty_vec;
auto b = empty_vec.begin();
auto e = empty_vec.end();
// b == e  (都是off-the-end迭代器)
```

📌 **Note**：
我们其实不知道，也不关心迭代器的精确类型， 我们都是通过auto来接收他们的类型


### 📝 迭代器操作

### 📋 标准容器迭代器操作表

| 操作 | 说明 |
|------|------|
| `*iter` | 返回迭代器所指元素的引用 |
| `iter->mem` | 等价于`(*iter).mem` |
| `++iter` | 指向容器中下一个元素 |
| `--iter` | 指向容器中前一个元素 |
| `iter1 == iter2` | 判断两个迭代器是否相等 |
| `iter1 != iter2` | 判断两个迭代器是否不等 |

**解引迭代器的有效性**：
- 我们只能解引表示元素的迭代器
- 解引无效迭代器或者off-the-end迭代器会出现未定义表现

**迭代器相等的条件**：
- 指向同一个元素，**或者**
- 都是同一个容器的off-the-end迭代器


### 📝 实例：使用迭代器访问元素

**改写大写字母程序**：
```cpp
string s("some string");
if (s.begin() != s.end()) {    // 确保s不为空
    auto it = s.begin();       // it指向第一个字符
    *it = toupper(*it);        // 将该字符变为大写
}
```

**工作原理**：
1. 首先检查字符串是否为空：比较begin和end
2. 如果不相等，说明至少有一个字符
3. 获取指向第一个字符的迭代器
4. 解引用迭代器获得字符，传递给toupper
5. 将结果赋值回第一个字符位置

### 📝 移动迭代器

**使用递增运算符**：
```cpp
// 处理字符直到遇到空格或字符串结束
for (auto it = s.begin(); it != s.end() && !isspace(*it); ++it)
    *it = toupper(*it);    // 将当前字符变为大写
```

**迭代器递增的含义**：
- 对于整数：`++i` 表示 "给i的值加1"
- 对于迭代器：`++it` 表示 "将迭代器向前推进一个位置"

**循环逻辑分析**：
1. 初始化it为s.begin()，指向第一个字符
2. 检查条件：it未到达末尾 且 当前字符不是空格
3. 如果条件满足，将当前字符转为大写
4. 执行++it移动到下一个字符
5. 重复直到遇到空格或字符串结束

⚠️ **重要警告**：
> end()返回的迭代器不指向任何元素，**不能对其递增或解引用**

### 📝 🔑 泛型编程的关键原则

**为什么使用 `!=` 而不是 `<`**：

C++程序员习惯性使用 `!=` 而非 `<` 来编写循环的原因：
- **通用性**：这种编码风格适用于所有类型的容器
- **迭代器限制**：只有少数容器（如vector和string）的迭代器支持 `<` 运算符
- **一致性**：所有标准库容器的迭代器都定义了 `==` 和 `!=` 运算符
- **可移植性**：不需要担心容器类型的具体实现

📍 **最佳实践**：养成使用迭代器和 `!=` 的习惯，这样代码可以适用于各种容器类型。

---

## ✅ 迭代器类型

### 📝 类型推导和命名

**自动类型推导**：
```cpp
vector<int> v;
auto it1 = v.begin();  // it1类型由编译器推导
string s;
auto it2 = s.begin();  // it2类型由编译器推导
```

**为什么不需要知道精确类型**：
- 类似于vector的size_type，我们通常不关心迭代器的确切类型
- 使用auto让编译器自动推导
- 专注于操作而非类型细节

### 📝 `iterator` 和 `const_iterator`

**两种迭代器类型**：
```cpp
vector<int>::iterator it;        // it能读写vector<int>元素
string::iterator it2;            // it2能读写string中的字符
vector<int>::const_iterator it3; // it3只能读取元素，不能写入
string::const_iterator it4;      // it4只能读取字符，不能写入
```

**`const_iterator`的特性**：
- 行为类似**const指针**
- 可以读取所指向的元素
- **不能**写入所指向的元素
- 如果vector或string是`const`，只能使用`const_iterator`

### 📝 begin和end的`const`类型选择

**自动类型选择机制**：
```cpp
vector<int> v;
const vector<int> cv;

auto it1 = v.begin();   // it1类型是vector<int>::iterator
auto it2 = cv.begin();  // it2类型是vector<int>::const_iterator
```

**类型选择规则**：
- 如果对象是`const` → 返回`const_iterator`
- 如果对象不是`const` → 返回`iterator`

### 📝 术语：迭代器和迭代器类型
* **“iterator”这个词有三层含义**：

  1. 抽象**概念**（一类能遍历容器的东西）；
  2. 某个容器定义的**迭代器类型**（如 `vector<int>::iterator`）；
  3. 该类型的**对象实例**（某个具体迭代器变量）。

* **什么算迭代器？**
  只要某类型支持一组通用操作（解引用取元素、`++` 移动到下一个等），这些操作支持访问容器元素，并在元素间移动，那么**在概念上**这就是迭代器。


* **每个容器都会给出一个名为 `iterator` 的嵌套类型**（以及只读的 `const_iterator`），它满足上述迭代器概念的操作集合。


### 📝 cbegin和cend函数（C++11）

**强制获取const_iterator，不管容器是否为`const/`**：
```cpp
auto it3 = v.cbegin();  // it3类型是vector<int>::const_iterator
```

**使用场景**：
- 当你只需要读取而不需要写入时
- 明确表达只读意图
- 提高代码安全性

**最佳实践建议**：
> 通常最好使用const类型（如const_iterator），除非你计划使用迭代器来改变元素。

---

## ✅ 结合解引用和成员访问

### 📝 箭头运算符的必要性

当解引用迭代器得到的对象有类类型时，我们可能需要访问其成员：

```cpp
vector<string> text;
// ... 假设text已填充数据
auto it = text.begin();

// 检查第一个字符串是否为空
(*it).empty();    // 正确：解引用it，然后调用empty
*it.empty();      // 错误！试图访问it的empty成员
```

**语法问题分析**：
- `(*it).empty()` ✅ 正确：先解引用，再访问成员
- `*it.empty()` ❌ 错误：等价于`*(it.empty())`，试图访问it的empty成员

**为什么需要括号**：
- 点运算符优先级高于解引用运算符
- 必须用括号改变运算顺序
- 没有括号会先执行成员访问

### 📝 箭头运算符 `->`

**语法简化**：
```cpp
// 繁琐的写法
(*it).empty();

// 简化的写法
it->empty();
```

**箭头运算符的定义**：
- `it->mem` 等价于 `(*it).mem`
- **结合解引用和成员访问**为单一操作
- 提高代码可读性

### 📝 实例：查找第一个空字符串

```cpp
// 打印text中第一个空行之前的每一行
for (auto it = text.cbegin(); 
     it != text.cend() && !it->empty(); 
     ++it)
    cout << *it << endl;
```

**代码分析**：
1. 使用`cbegin()`获取const_iterator（只读访问）
2. 条件检查：
   - `it != text.cend()`：确保没有处理完所有元素
   - `!it->empty()`：当前字符串不为空
3. 输出当前元素并移动到下一个
4. 遇到空字符串时停止

**重要提醒**：
> 循环读取但不写入text元素，因此使用cbegin和cend来控制迭代。

---

## ✅ 某些vector操作会使迭代器失效

### 📝 迭代器失效的原理

**动态增长的副作用**：
- vector可以动态增长（通过push_back等操作）
- 改变vector大小的操作**可能会使所有迭代器失效**
- 详细原理将在§9.3.6中详述

⚠️ **关键警告**：
> 使用迭代器的循环**不应该**向其所遍历的容器添加元素。

**为什么会失效**：
1. 容器重新分配内存时
2. 原有迭代器指向的内存位置可能无效
3. 继续使用会导致未定义行为

**安全编程实践**：
- 在迭代过程中避免修改容器大小
- 如需修改，重新获取迭代器
- 优先使用算法而非手动循环

---

## ✅ 3.4.2 迭代器算术

### 📝 基本概念

**支持算术的迭代器**：
- string和vector的迭代器支持额外操作
- 可以一次移动多个元素
- 支持所有关系运算符
- 这些操作被称为**迭代器算术**

### 📋 vector和string迭代器支持的操作

| 操作 | 说明 |
|------|------|
| `iter + n` | 向前移动n个元素的迭代器 |
| `iter - n` | 向后移动n个元素的迭代器 |
| `iter1 += n` | 复合赋值，相当于iter1 = iter1 + n |
| `iter1 -= n` | 复合赋值，相当于iter1 = iter1 - n |
| `iter1 - iter2` | 两个迭代器间的距离 |
| `>, >=, <, <=` | 关系运算符，比较位置先后 |

### 📝 算术运算详解

**加法和减法运算**：
```cpp
// 计算指向中间元素的迭代器
auto mid = vi.begin() + vi.size() / 2;
```

**结果的有效性**：
- 结果必须指向**同一个容器**中的元素
- 或指向容器尾部之后的位置
- 超出范围的结果是未定义行为

**实例分析**：
如果vi有20个元素：
- `vi.size() / 2` = 10
- `mid` = `vi.begin() + 10`
- 等价于`vi[10]`， 也就是指向刚刚过第十个的第一个元素

### 📝 迭代器比较

**关系运算符的含义**：
```cpp
if (it < mid)
    // 处理vi前半部分的元素
```

**比较规则**：
- 迭代器必须有效且指向同一个容器
- 一个迭代器"小于"另一个，当且仅当它指向的元素在容器中出现更早
- 只能比较相同容器的迭代器

### 📝 迭代器减法

**距离计算**：
```cpp
auto distance = iter1 - iter2;
```

**difference_type类型**（迭代器相减结果）：
- 结果类型是**有符号整数**类型
- 命名为`difference_type`
- vector和string都定义了这个类型
- 支持负数结果（减法可能得到负值）

### 📝 实例：二分搜索算法

**算法思路**：
- 在已排序序列中查找特定值
- 检查中间元素
- 根据比较结果缩小搜索范围
- 重复直到找到或搜索空间为空

**代码实现**：
```cpp
// text必须是有序的
// beg和end表示我们搜索的范围
auto beg = text.begin(), end = text.end();
auto mid = text.begin() + (end - beg)/2;  // 初始中点

// 当还有元素尚未检查且尚未找到sought时
while (mid != end && *mid != sought) {
    if (sought < *mid)          // 我们要找的元素在前半部分吗？
        end = mid;              // 如果是，调整范围忽略后半部分
    else                        // 我们要找的元素在后半部分
        beg = mid + 1;          // 从中点之后的元素开始查找
    mid = beg + (end - beg)/2;  // 新的中点
}
```

**算法步骤分析**：

1. **初始化**：
   - `beg`：范围起始，`end`：范围结束
   - `mid`：当前中点位置

2. **循环条件**：
   - `mid != end`：还有元素需要检查
   - `*mid != sought`：尚未找到目标

3. **范围调整**：
   - 如果目标小于中间值：在前半部分，调整`end = mid`
   - 如果目标大于中间值：在后半部分，调整`beg = mid + 1`
   - 重新计算中点

4. **结果判断**：
   - 循环结束时，如果`mid != end`，说明找到了
   - 如果`mid == end`，说明目标不在text中

**关键技巧**：
- 计算新中点：`beg + (end - beg)/2`
- 避免整数溢出，比直接`(beg + end)/2`更安全

---

## 🍃 小结

### 📚 核心知识体系

**迭代器的三重价值**：

1. **通用性**：统一的容器访问接口
   - 适用于所有标准库容器
   - 不依赖特定容器的实现细节
   - 为泛型编程提供基础

2. **安全性**：比原始指针更安全
   - 类型安全的元素访问
   - 明确的有效性概念
   - const_iterator提供只读保护

3. **灵活性**：支持多种操作模式
   - 基本的前进/后退操作
   - 算术运算（适用于随机访问迭代器）
   - 统一的比较和解引用接口

### ⚡ 关键概念精要

**四个核心概念**：

1. **begin/end模式**：
   - begin()指向第一个元素
   - end()指向"最后一个元素之后"的位置
   - [begin, end)左闭右开区间

2. **迭代器类型**：
   - `iterator`：可读写
   - `const_iterator`：只读
   - 使用auto自动推导类型

3. **迭代器算术**：
   - 只有vector和string支持
   - 支持加减法和关系比较
   - difference_type表示距离

4. **失效机制**：
   - 修改容器大小可能使迭代器失效
   - 避免在迭代过程中修改容器

### 🛡️ 最佳实践指南

**编程习惯清单**：

✅ **推荐做法**：
- 使用`!=`而不是`<`进行循环比较
- 优先使用`const_iterator`当不需要修改时
- 使用`auto`自动推导迭代器类型
- 使用箭头运算符`->`简化成员访问
- 使用`cbegin()/cend()`明确表达只读意图

❌ **避免做法**：
- 在迭代循环中修改容器大小
- 对end()迭代器进行解引用或递增
- 比较不同容器的迭代器
- 假设所有容器都支持算术运算

### 🔄 迭代器vs其他访问方式

| 访问方式 | 适用性 | 性能 | 安全性 | 泛型性 |
|---------|-------|------|--------|--------|
| 下标运算符 | 少数容器 | 最高 | 中等 | 差 |
| 迭代器 | 所有容器 | 高 | 高 | 最佳 |
| range-for | 所有容器 | 高 | 最高 | 好 |

### 💡 深层理解

**迭代器的设计哲学**：

1. **抽象边界**：
   - 将"位置"的概念从具体的索引抽象出来
   - 提供统一的"移动到下一个位置"操作
   - 隐藏底层数据结构的实现细节

2. **开闭原则**：
   - 对扩展开放：新容器类型可以定义自己的迭代器
   - 对修改封闭：现有算法无需修改即可适用新容器

3. **零开销抽象**：
   - 编译器优化后性能接近手写循环
   - 提供高级抽象但不牺牲效率

**记住三个要点**：
1. 📌 迭代器是指针概念的泛化，提供统一的容器访问接口
2. 📌 优先使用const_iterator和cbegin/cend保证安全性
3. 📌 迭代器算术只适用于支持随机访问的容器（如vector、string）

迭代器不仅是访问容器的工具，更是C++泛型编程的基石，为STL算法库的设计奠定了理论基础。理解迭代器的概念和使用方法，是掌握现代C++编程的重要一步。