## Exercise 3.12

**(a)** `vector<vector<int>> ivec;`
✅ 合法。定义一个“元素为 `vector<int>` 的 `vector`”，默认初始化为空。

**(b)** `vector<string> svec = ivec;`
❌ 不合法。`svec` 的类型是 `vector<string>`，而 `ivec` 的类型是 `vector<vector<int>>`，**元素类型完全不同**，没有可用的转换。

**(c)** `vector<string> svec(10, "null");`
✅ 合法。生成 **10 个元素** 的 `vector<string>`，每个元素的值都是 `"null"`。

---

## Exercise 3.13

问：每个定义产生多少元素？这些元素的值是什么？

| 定义                                     | 结果                                                     |
| -------------------------------------- | ------------------------------------------------------ |
| **(a)** `vector<int> v1;`              | 0 个元素（空）                                               |
| **(b)** `vector<int> v2(10);`          | 10 个元素，**全为 0**（值初始化）                                  |
| **(c)** `vector<int> v3(10, 42);`      | 10 个元素，**全为 42**                                       |
| **(d)** `vector<int> v4{10};`          | 1 个元素，值为 **10**（花括号=列出元素）                              |
| **(e)** `vector<int> v5{10, 42};`      | 2 个元素，依次为 **10**、**42**                                |
| **(f)** `vector<string> v6{10};`       | 10 个元素，**每个是空字符串**（无法把 `10` 当成 `string` 元素，转而匹配“大小构造”） |
| **(g)** `vector<string> v7{10, "hi"};` | 10 个元素，**每个是 `"hi"`**（同理匹配“大小 + 初值”构造）                 |

> 记忆点：
>
> * `()` 更像“构造参数”：`(n)`、`(n, val)`
> * `{}` 更像“罗列元素”；当花括号里的类型**无法**当作元素列表时，才会退化匹配“大小/初值”构造。
