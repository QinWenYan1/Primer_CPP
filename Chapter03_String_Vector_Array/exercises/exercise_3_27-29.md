

## Exercise 3.27

给定 `txt_size()` 返回 `int`。

```cpp
unsigned buf_size = 1024;

(a) int ia[buf_size];     // ❌ 非法
(b) int ia[4 * 7 - 14];   // ✅ 合法（大小=14）
(c) int ia[txt_size()];   // ❌ 非法（除非 txt_size 是 constexpr）
(d) char st[11] = "fundamental"; // ❌ 非法
```

**原因**

* 数组维度必须是**编译期常量表达式**。`buf_size` 不是 `constexpr` → (a) 不行。
* `4*7-14` 是常量表达式 → (b) 可以，大小 14。
* 普通函数调用不是常量表达式 → (c) 不行（只有在 `constexpr int txt_size()` 时才行）。
* `"fundamental"` 长度 11，还要加终止符 `'\0'` → 需要 **12**，`char[11]` 放不下 → (d) 不行。

---

## Exercise 3.28

这些数组各元素的初始值？

```cpp
string sa[10];   // 10 个空字符串（默认构造）
```

```cpp
int ia[10];      // （全局定义）10 个 0
```

```cpp
int main() {
    string sa2[10]; // 10 个空字符串（默认构造）
    int ia2[10];    // 未定义的垃圾值（局部内置类型默认初始化）
}
```

**规则回顾**

* `string` 这类类类型默认构造 → 空字符串。
* **全局/静态存储期**的内置类型 → 值初始化为 0。
* **局部**内置类型默认初始化 → 未定义值。

---

## Exercise 3.29

**用数组而不是 `vector` 的一些缺点：**

* **大小固定**：必须是编译期常量，运行期不能增删元素。
* **不可直接拷贝/赋值** 整个数组，语法受限。
* **易衰变为指针**：类型信息（含维度）丢失，易出错。
* **接口贫乏**：无成员函数/size 信息；与算法配合不如容器直观。
* **安全性差**：无边界检查、易越界、易造成缓冲区溢出。
* **初始化受限**：不能用 `auto` 从列表推断类型；维度必须常量表达式。
* **可维护性差**：手动管理指针/下标，出错成本高。
