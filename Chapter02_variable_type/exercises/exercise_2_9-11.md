# 📚 C++ Primer 2.2 课后练习题解答

---

## 🔍 Exercise 2.9: 解释定义语句的合法性

### (a) `std::cin >> int input_value;`

**分析**：**非法**

**问题**：
- 这是试图在输入语句中同时定义变量的语法错误
- `>>` 操作符期望左侧是输入流，右侧是已定义的变量

**正确写法**：
```cpp
int input_value;
std::cin >> input_value;
```
或者：
```cpp
int input_value;
std::cin >> input_value;
```

---

### (b) `int i = { 3.14 };`

**分析**：**非法**

**问题**：
- 使用列表初始化时，从 `double` (3.14) 到 `int` 的转换会丢失信息
- 列表初始化不允许窄化转换（narrowing conversion）

**正确写法**：
```cpp
int i = {3};              // 使用整数
int i = 3.14;             // 使用拷贝初始化（允许窄化转换）
int i(3.14);              // 使用直接初始化（允许窄化转换）
double d = {3.14};        // 使用匹配的类型
```

---

### (c) `double salary = wage = 9999.99;`

**分析**：**非法**

**问题**：
- 变量 `wage` 未定义就被使用
- 赋值是从右到左进行的，但 `wage` 必须先定义

**正确写法**：
```cpp
double wage = 9999.99;
double salary = wage;
```
或者：
```cpp
double salary = 9999.99, wage = 9999.99;  // 同时定义并初始化
```
或者：
```cpp
double wage, salary = wage = 9999.99;     // 先定义wage，再进行连续赋值
```

---

### (d) `int i = 3.14;`

**分析**：**合法**

**说明**：
- 这是拷贝初始化，允许隐式类型转换
- `double` 值 3.14 会被截断为 `int` 值 3
- 编译器可能会给出警告，但语法上是合法的

**结果**：`i` 的值为 3

---

## 🔍 Exercise 2.10: 变量的初始值

```cpp
std::string global_str;
int global_int;
int main()
{
    int local_int;
    std::string local_str;
}
```

### 📝 初始值分析

| 变量名 | 作用域 | 类型 | 初始值 | 说明 |
|--------|--------|------|--------|------|
| `global_str` | 全局 | `std::string` | `""` (空字符串) | 全局变量，string类提供默认初始化 |
| `global_int` | 全局 | `int` | `0` | 全局变量，内置类型初始化为0 |
| `local_int` | 局部 | `int` | **未定义** | 函数内部的内置类型变量未初始化 |
| `local_str` | 局部 | `std::string` | `""` (空字符串) | string类提供默认初始化，与作用域无关 |

### 📝 关键规则总结

**内置类型初始化规则**：
- **全局/静态变量**：自动初始化为 0
- **局部变量**：未初始化，值未定义

**类类型初始化规则**：
- **无论作用域**：由类的默认构造函数决定
- **std::string**：默认初始化为空字符串

### ⚠️ 重要提醒

- `local_int` 具有未定义的值，使用前必须先初始化
- 访问未初始化的 `local_int` 会导致未定义行为
- 建议总是显式初始化局部变量以避免潜在问题

---

## 🔍 Exercise 2.11: 判断声明还是定义

### (a) `extern int ix = 1024;`

**分析**：**定义 (Definition)**

**解释**：
- 虽然使用了 `extern` 关键字，但提供了**初始化器** (= 1024)
- 当 `extern` 声明包含初始化器时，它就变成了定义
- 初始化器会**覆盖** `extern` 的效果，使其成为定义而不是单纯的声明

---

### (b) `int iy;`

**分析**：**定义 (Definition)**

**解释**：
- 这是一个简单的变量定义语句
- 没有 `extern` 关键字，因此这是定义而不是声明
- 创建了变量并分配存储空间


---

### (c) `extern int iz;`

**分析**：**声明 (Declaration)**

**解释**：
- 使用了 `extern` 关键字且**没有提供初始化器**
- 这是纯粹的声明，不是定义
- 告诉编译器 `iz` 是一个 `int` 类型的变量，但不创建它

---

## 📝 核心概念总结

### 🎯 声明 vs 定义的判断规则

| 情况 | 类型 | 说明 |
|------|------|------|
| `extern int var;` | **声明** | extern + 无初始化器 = 声明 |
| `extern int var = value;` | **定义** | extern + 有初始化器 = 定义 |
| `int var;` | **定义** | 无extern = 定义 |
| `int var = value;` | **定义** | 无extern + 有初始化器 = 定义 |

### ⚡ 关键要点

1. **`extern` 的作用**：
  - 告诉编译器变量在其他地方定义
  - 支持分离式编译

2. **初始化器的特殊作用**：
  - 一旦提供初始化器，就成为定义
  - 即使有 `extern` 关键字也会被覆盖

3. **分离式编译的重要性**：
  - 声明：使名字为程序所知（可以多次）
  - 定义：创建实体并分配存储（必须恰好一次）

### 💡 实际应用

```cpp
// 文件1: definition.cpp
int global_var = 42;        // 定义

// 文件2: usage.cpp  
extern int global_var;      // 声明
int main() {
   std::cout << global_var;  // 使用在其他文件中定义的变量
   return 0;
}

## 📝 总结

这些练习强调了几个重要概念：

1. **变量必须先定义后使用**
2. **列表初始化提供类型安全检查**
3. **不同作用域的初始化规则不同**
4. **类类型和内置类型的默认初始化行为不同**
5. **未初始化的局部变量是常见的错误源**

掌握这些规则对编写安全可靠的C++代码至关重要！