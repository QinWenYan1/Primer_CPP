# 📚 Chapter Summary — 第二章总结

---

## 🌟 章节核心

**类型是 C++ 编程的基础**

类型 (types) 在 C++ 中是根本性的。每个类型定义了：
- **存储需求** (storage requirements)：对象在内存中占用多少空间
- **可执行操作** (operations)：可以对该类型对象执行哪些操作

语言提供了一套基础的内置类型 (built-in types)，如 `int` 和 `char`，它们与机器硬件表示紧密相关。

**类型可以是**：
- **非常量 (nonconst)** 或 **常量 (const)**：const 对象必须被初始化，一旦初始化其值就不能改变
- **复合类型 (compound type)**：基于另一个类型定义的类型，如指针 (pointers) 或引用 (references)

**自定义类型**：语言允许我们通过定义类 (classes) 来定义自己的类型。标准库使用类功能提供了更高级的抽象，如 IO 和 `string` 类型。

---

## 📖 定义术语 (Defined Terms)

### 🔤 A-C

**address 地址**：内存中字节的编号，用于定位字节的位置。

**alias declaration 别名声明**：定义类型同义词：`using name = type` 将 `name` 声明为类型 `type` 的同义词。

**arithmetic types 算术类型**：表示布尔值、字符、整数和浮点数的内置类型。

**array 数组**：保存一组未命名对象的数据结构，通过索引访问。第 3.5 节详细介绍数组。

**auto**：类型说明符 (type specifier)，从初始化器推导变量类型。

**base type 基础类型**：类型说明符，可能被 `const` 修饰，出现在声明符 (declarators) 前面。基础类型为声明中的声明符提供公共类型基础。

**bind 绑定**：将名称与给定实体关联，使得对名称的使用就是对底层实体的使用。例如，引用是绑定到对象的名称。

**byte 字节**：最小的可寻址内存单元。在大多数机器上一个字节是 8 位。

**class member 类成员**：类的一部分。

**compound type 复合类型**：基于另一种类型定义的类型。

**const**：类型限定符 (type qualifier)，用于定义不可改变的对象。`const` 对象必须初始化，因为定义后无法给它们赋值。

**const pointer 常量指针**：`const` 的指针。

**const reference 常量引用**：reference to `const` 的口语同义词。

**constant expression 常量表达式**：可以在编译时求值的表达式。

**constexpr**：表示常量表达式的变量。第 6.5.2 节 (p. 239) 介绍 `constexpr` 函数。

**conversion 转换**：将一种类型的值转换为另一种类型值的过程。语言定义了内置类型之间的转换。

### 🔤 D-H

**data member 数据成员**：构成对象的数据元素。给定类的每个对象都有该类数据成员的自己副本。数据成员可以在类内声明时初始化。

**declaration 声明**：断言变量、函数或类型在别处定义的存在。名称在定义或声明前不能使用。

**declarator 声明符**：声明的一部分，包括正在定义的名称和可选的类型修饰符。

**decltype**：类型说明符，推导变量或表达式的类型。

**default initialization 默认初始化**：没有给出显式初始化器时对象的初始化方式。类类型对象的初始化方式由类控制。内置类型在全局作用域定义的对象初始化为 0；在局部作用域定义的对象未初始化，值未定义。

**definition 定义**：为指定类型的变量分配存储空间，并可选地初始化变量。名称在定义或声明前不能使用。

**escape sequence 转义序列**：表示字符的替代机制，特别是对于没有可打印表示的字符。转义序列是反斜杠后跟一个字符、三位或更少八进制数字，或 `x` 后跟十六进制数字。

**global scope 全局作用域**：在所有其他作用域之外的作用域。

**header guard 头文件保护**：用于防止头文件在单个文件中被多次包含的预处理器变量。

### 🔤 I-L

**identifier 标识符**：构成名称的字符序列。标识符区分大小写。

**in-class initializer 类内初始化器**：作为类数据成员声明一部分提供的初始化器。类内初始化器必须跟在 `=` 符号后或包围在花括号内。

**in scope 在作用域内**：从当前作用域可见的名称。

**initialized 已初始化**：定义时给定初值的变量。变量通常应该被初始化。

**inner scope 内层作用域**：嵌套在另一个作用域内的作用域。

**integral types 整型**：参见 arithmetic type。

**list initialization 列表初始化**：使用花括号包围一个或多个初始化器的初始化形式。

**literal 字面值**：如数字、字符或字符串等值。值不能改变。字面字符用单引号包围，字面字符串用双引号包围。

**local scope 局部作用域**：block scope 的口语同义词。

**low-level const 底层 const**：不是顶层的 `const`。这种 `const` 是类型的组成部分，永远不会被忽略。

### 🔤 M-P

**member 成员**：类的一部分。

**nonprintable character 非打印字符**：没有可见表示的字符，如控制字符、退格、换行等。

**null pointer 空指针**：值为 0 的指针。空指针有效但不指向任何对象。

**nullptr**：表示空指针的字面常量。

**object 对象**：具有类型的内存区域。变量是有名称的对象。

**outer scope 外层作用域**：包围另一个作用域的作用域。

**pointer 指针**：可以保存对象地址、对象末尾后一个位置的地址或零的对象。

**pointer to const 指向常量的指针**：不能用来改变所指对象值的指针。

### 🔤 P-S (continued)

**preprocessor 预处理器**：作为 C++ 程序编译一部分运行的程序。

**preprocessor variable 预处理器变量**：由预处理器管理的变量。编译程序前，预处理器用其值替换每个预处理器变量。

**reference 引用**：另一个对象的别名。

**reference to const 常量引用**：不能改变所引用对象值的引用。常量引用可以绑定到 `const` 对象、非 `const` 对象或表达式的结果。

**scope 作用域**：程序中名称有意义的部分。C++ 有几个级别的作用域：
- **global 全局**：在任何其他作用域外定义的名称
- **class 类**：在类内定义的名称  
- **namespace 命名空间**：在命名空间内定义的名称
- **block 块**：在块内定义的名称

作用域嵌套。一旦名称被声明，它就可以访问直到声明它的作用域结束。

**separate compilation 分离式编译**：将程序分割成多个独立源文件的能力。

**signed 有符号**：保存负值或正值（包括零）的整数类型。

**string**：表示可变长度字符序列的标准库类型。

**struct**：用于定义类的关键字。

### 🔤 T-V

**temporary 临时对象**：编译器在表达式求值时创建的未命名对象。临时对象存在直到包含创建它的表达式的最大表达式结束。

**top-level const 顶层 const**：指定对象不可改变的 `const`。

**type alias 类型别名**：作为另一种类型同义词的名称。通过 `typedef` 或别名声明定义。

**type checking 类型检查**：编译器验证给定类型对象的使用方式与该类型定义一致的过程术语。

**type specifier 类型说明符**：类型的名称。

**typedef**：定义另一种类型的别名。当 `typedef` 出现在声明的基础类型中时，声明中定义的名称是类型名称。

**undefined 未定义**：语言未指定含义的用法。故意或无意依赖未定义行为是难以跟踪的运行时错误、安全问题和可移植性问题的重要来源。

**uninitialized 未初始化**：没有初值定义的变量。通常，试图访问未初始化变量的值会导致未定义行为。

**unsigned 无符号**：只保存大于等于零值的整数类型。

**variable 变量**：命名的对象或引用。在 C++ 中，变量使用前必须声明。

**void\***：可以指向任何非 `const` 类型的指针类型。这种指针不能被解引用。

**void type 空类型**：没有操作和值的特殊用途类型。不能定义 `void` 类型的变量。

**word 字**：给定机器上整数计算的自然单元。通常字足够大以容纳地址。在 32 位机器上，字通常是 4 字节。

### 🔤 运算符和预处理器指令

**& operator 取址运算符**：产生应用对象地址的运算符。

**\* operator 解引用运算符**：解引用指针返回指针指向的对象。对解引用结果赋值会给底层对象赋新值。

**# define**：定义预处理器变量的预处理器指令。

**# endif**：结束 `#ifdef` 或 `#ifndef` 区域的预处理器指令。

**# ifdef**：测试给定变量是否已定义的预处理器指令。

**# ifndef**：测试给定变量是否未定义的预处理器指令。