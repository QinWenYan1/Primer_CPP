# 📘 2.3 Section — 复合类型 (Compound Types)

> 本章笔记基于《C++ Primer》第五版整理，详细介绍了 C++ 中的复合类型系统。

---

## 🧠 本章核心概念

- ✯ 复合类型基本概念
- ✯ 引用 (References)
  - 引用的定义和特性
  - 引用是别名
  - 引用的初始化要求
  - 引用的限制
- ✯ 指针 (Pointers)
  - 指针的定义和特性
  - 取地址操作符 (&)
  - 解引用操作符 (*)
  - 指针值的四种状态
  - 空指针 (null pointer)
  - void* 指针
- ✯ 复合类型声明的理解
  - 基本概念
  - 多变量定义的注意事项
  - 指针的指针
  - 指向指针的引用
- ✯ 符号的多重含义

---

## ✅ 复合类型基本概念

**复合类型**是基于其他类型定义的类型。C++ 有几种复合类型，本章重点介绍两种：**引用 (references)** 和 **指针 (pointers)**。

**声明的组成**：
- **基类型 (base type)** + **声明符列表 (declarators)**
- 每个声明符命名一个变量，并给变量一个与基类型相关的类型

---

## ✅ 引用 (References)

### 📝 基本定义

**引用**定义了对象的**替代名称**。引用类型"引用"另一种类型，使用 `&d` 形式定义：

```cpp
int ival = 1024;
int &refVal = ival;     // refVal 引用 ival（是 ival 的另一个名字）
int &refVal2;           // 错误：引用必须被初始化
```
- 原本当我们初始化一个变量时，初始化器的值会被复制到变量中进行初始化。但是我们在初始化引用时，并不是将初始化器的值复制进去，而是将**引用和初始化器**捆绑。

### 📝 引用是别名

**重要特性**：
- 引用**不是对象**，而是已存在对象的另一个名字
- 引用定义后，对该引用的**所有操作**实际上都是对被引用对象的操作
- 由于引用不是对象，我们**不能定义**引用的引用

```cpp
refVal = 2;             // 给 ival 赋值 2
int ii = refVal;        // 等同于 ii = ival
int &refVal3 = refVal;  // 将refVal3绑定到refVal所绑定的对象上
int i = refVal;         // 初始化i为refVal绑定的对象的值
```

### 📝 初始化要求

**必须初始化**：
- 引用必须在定义时初始化
- 一旦初始化，引用就永远绑定到其初始对象
- **没有方法让引用重新绑定到另一个对象**

**类型匹配**：
- 引用类型必须与其引用的对象类型**完全匹配**
- 引用只能绑定到**对象**，不能绑定到字面值或表达式结果

```cpp
int &refVal4 = 10;      // 错误：初始化器必须是对象，这个是个字面值
double dval = 3.14;
int &refVal5 = dval;    // 错误：初始化器必须是 int 对象
```

### 📝 引用定义

可以在单个定义中定义多个引用，每个引用标识符前都必须有 `&` 符号：

```cpp
int i = 1024, i2 = 2048;
int &r = i, r2 = i2;    // r 是引用，r2 是 int
int i3 = 1024, &ri = i3; // i3 是 int，ri 是引用
int &r3 = i3, &r4 = i2; // r3 和 r4 都是引用
```

**重要限制**：
- 不能定义引用的引用（引用不是对象）

---

## ✅ 指针 (Pointers)

### 📝 基本定义

**指针**是一种复合类型，"指向"另一种类型。与引用不同：
- 指针**本身就是对象**
- 指针可以被赋值和拷贝
- 一个指针在其生命周期内可以指向不同对象
- 指针定义时不需要初始化

```cpp
int *ip1, *ip2;         // ip1 和 ip2 都是指向 int 的指针
double dp, *dp2;        // dp2 是指向 double 的指针，dp 是 double
```

### 📝 取地址操作符 (&)

使用**地址操作符** (`&`) 获取对象的地址：

```cpp
int ival = 42;
int *p = &ival;         // p 存储 ival 的地址，p 是指向 ival 的指针
```

**类型匹配**：指针类型必须与所指对象类型匹配，因为指针类型常常用于推断所指的对象类型，否则操作会失败：

```cpp
double dval;
double *pd = &dval;     // 正确：初始化器是 double 的地址
double *pd2 = pd;       // 正确：初始化器是指向 double 的指针
int *pi = pd;           // 错误：pi 和 pd 的类型不同
pi = &dval;             // 错误：试图将 double 的地址赋给指向 int 的指针
```

### 📝 指针值的四种状态

1. **指向一个对象**
2. **指向紧邻对象所占空间的下一个位置**
3. **空指针，没有绑定到任何对象**
4. **无效指针**（除前三种之外的其他值）

⚠️ 拷贝或访问无效指针的结果是未定义的

### 📝 解引用操作符 (*)

当指针指向对象时，使用**解引用操作符** (`*`) 访问该对象：

```cpp
int ival = 42;
int *p = &ival;         // p 存储 ival 的地址
cout << *p;             // * 产生 p 指向的对象，输出 42
```

**解引用赋值**：
```cpp
*p = 0;                 // * 产生对象，给 ival 通过 p 赋值 0
cout << *p;             // 输出 0
```

⚠️ **重要**：只能解引用指向有效对象的指针

### 📝 空指针 (Null Pointers)

**空指针**不指向任何对象。获得空指针的方法：

```cpp
int *p1 = nullptr;      // 等价于 int *p1 = 0;
int *p2 = 0;            // 直接用字面值常量 0 初始化
int *p3 = NULL;         // 等价于 int *p3 = 0;（需要 #include cstdlib）
```

- **现代C++建议**：使用 **`nullptr`** 而不是 `NULL`。 `nullptr`拥有一个可以转换为其他指针类型的类型
- 这在C++不推荐的去将`int`赋值给指针
- 老程序有些时候会使用**预处理器变量(preprocessor variable)** `NULL`，这个变量被 `cstdlib`定义为0这个值
- 预处理器变量不属于std命名空间， 不需要std::前缀

**空指针检查**：
```cpp
int zero = 0;
pi = zero;              // 错误：不能将 int 变量赋给指针
```

##### ⚠️ 警告
- **未初始化的指针**是高风险的：指针所在内存中的位可能指向随机地址，导致运行时崩溃
- 指针应该**始终初始化**：可以避免潜在错误

### 📝 赋值(assignment)与指针
- 不同于引用无法改变指向对象，指针可以通过赋值的方式来指向不同的对象
- 有些时候很难追踪是否赋值改动了指针或所指对象，**但我们记住赋值改变的永远是左边运算数**

```cpp
int *pi = 0; // pi is initialized but addresses no object
pi = &ival; // value in pi is changed; pi now points to ival
*pi = 0; // value in ival is changed; pi is unchanged
```

### 📝 指针的条件判断

```cpp
int ival = 1024;
int *pi = 0;            // pi 是有效的空指针
int *pi2 = &ival;       // pi2 是指向 ival 的有效指针
if (pi)  // ...         // pi 值为 0，条件为 false
if (pi2) // ...         // pi2 指向 ival，条件为 true
```

- **任何非零指针**都求值为 `true`
- **相同类型**以及**可用**的指针是可以通过 `==` 或 `!=` 来比较
- `==` 来说，地址相同就是 `true`， 不同就是 `false`， `!=` 相反
- 当两个指针指向不同对象但它们地址正好相同（如一个指向对象末尾、一个指向下一个对象开头），它们在比较时也会被认为是相等的。**本质是地址本身的比较**

### 📝 void* 指针

- **void*** 是特殊的指针类型，可以存放**任意类型对象的地址**
- **void*** 指针所指向的对象类型未知

```cpp
double obj = 3.14, *pd = &obj;
void *pv = &obj;        // obj 可以是任意类型的对象
pv = pd;                // pv 可以存放任意类型的指针
```
- 我们可以将 `void*` 与其他指针**比较**，**传入函数或从函数返回**，还可以把各种类型地址**赋值**给 `void*` 类型的变量
- **限制**：我们**不能直接操作** `void*` 指针所指的对象，因为不知道对象类型
- 通常，我们使用 void* 指针是为了把内存当作**原始内存块**来处理，而不是用这个指针来访问存储在那段内存中的对象。

---

## ✅ 复合类型声明的理解

### 📝 基本概念
- 一个变量定义可以包含一个基本类型和单个或多个<b>声明器(declarators)</b>
- **声明器**是声明中的一部分，紧跟在基础类型后面，包含**变量名**及其所有<b>类型修改器(type modifier)</b>的组合, 如 `*p`, `&r`, `arr[10]`
- 声明器可以在同一个变量定义中与基础类型结合，定义一个或多个不同复合类型的变量
- **类型修改器**是对基础类型的修饰（比如：指针、引用、数组、函数等），如 `*`，`&`

```cpp
// i is an int; p is a pointer to int; r is a reference to int
int i = 1024, *p = &i, &r = i;
```
这里`&`符号在不同上下文中有不同含义

### 📝 符号的多重含义

`&` 和 `*` 符号在不同上下文中有不同含义：

```cpp
int i = 42;
int &r = i;             // & 是声明的一部分，r 是引用
int *p;                 // * 是声明的一部分，p 是指针
p = &i;                 // & 是地址操作符
*p = i;                 // * 是解引用操作符
int &r2 = *p;           // & 是声明的一部分，* 是解引用操作符
```

### 📝 定义多个变量

- **常见误解**：类型修饰符（`*` 或 `&`）**不**适用于一条语句中的所有变量
- 因此，虽然多个变量可以在一条语句中声明，但每个变量的修饰符（如 * 或 &）是作用于**变量本身**，而不是基础类型，所以要特别注意每个变量的具体类型。

```cpp
int* p;                 // 合法但可能误导（暗示 int* 是类型）
int* p1, p2;           // p1 是指向 int 的指针，p2 是 int
```
⚠️ `*` 和 `&` 属于声明器，不属于基础类型，因此在一条声明中，每个变量的类型修饰都必须单独看清楚，不能想当然地套用

⚠️ 这两个定义的基础类型都是`int`，但是 `*` 修改了 `p1` 和 `p`的类型

**推荐风格**：
```cpp
int *p1, *p2;          // p1 和 p2 都是指向 int 的指针
```

或者每个变量单独定义：
```cpp
int* p1;               // p1 是指向 int 的指针
int* p2;               // p2 是指向 int 的指针
```

### 📝 指针的指针

**指针是对象**，所以可以有指向指针的指针：

```cpp
int ival = 1024;
int *pi = &ival;       // pi 指向 int
int **ppi = &pi;       // ppi 指向一个 int 指针
```

**访问原始对象**：
```cpp
cout << "ival: " << ival << "\n"
     << "indirect value: " << *pi << "\n"
     << "doubly indirect value: " << **ppi << endl;
```

### 📝 指向指针的引用

**引用不是对象**，所以没有指向引用的指针。但**指针是对象**，所以可以定义对指针的引用：

```cpp
int i = 42;
int *p;                // p 是指向 int 的指针
int *&r = p;           // r 是对指针 p 的引用
r = &i;                // r 引用指针 p，相当于使 p 指向 i
*r = 0;                // 解引用 r 得到 i，将 i 改为 0
```

**理解复杂声明**：从右到左读取最有帮助
从变量名向左看：符号最近的是 &，说明是引用；再看左边是 *，说明引用的是指针；最后的 int 是基础类型。

---

## 🍃 小结

### 📚 核心知识体系

**复合类型概念**：
- 复合类型基于其他类型定义，扩展了类型系统的表达能力
- 引用和指针提供间接访问对象的机制
- 声明由基类型和声明符组成，每个声明符定义一个变量

**引用特性**：
- 引用是对象的别名，不是独立的对象
- 必须初始化且不能重新绑定
- 类型必须完全匹配，只能绑定到对象

**指针特性**：
- 指针是存储对象地址的对象
- 可以赋值、拷贝和指向不同对象
- 有四种可能的状态，只有指向有效对象时才能解引用

### ⚡ 关键概念精要

**操作符的双重含义**：
- `&`：声明中表示引用，表达式中表示取地址
- `*`：声明中表示指针，表达式中表示解引用
- 上下文决定含义，理解这点对读写代码至关重要

**类型安全**：
- 引用和指针的类型必须与目标对象类型匹配
- 类型检查防止了许多常见的编程错误
- void* 提供了类型擦除但牺牲了类型安全

**复杂声明解读**：
- 从右到左读取复杂的指针和引用声明
- 理解 `int *&r` 是"对int指针的引用"
- 掌握指针的指针等嵌套结构

### 🛡️ 实践防护策略

**引用最佳实践**：
- 总是在定义时初始化引用
- 使用引用避免不必要的拷贝
- 引用适合函数参数和返回值

**指针安全使用**：
- **总是初始化指针**，未初始化指针是常见错误源
- 使用 `nullptr` 而不是 `NULL` 或 0
- 解引用前检查指针有效性
- 避免悬垂指针和野指针

**代码风格建议**：
- 选择一致的声明风格（`int* p` vs `int *p`）
- 复杂类型每个变量单独声明
- 使用有意义的变量名提高可读性

### 🔗 学习路径指引

复合类型为后续概念奠定基础：
- **数组和字符串**：指针和数组的密切关系
- **函数**：引用和指针参数的传递机制
- **类和对象**：成员指针和引用成员
- **动态内存管理**：指针在堆内存操作中的关键作用
- **智能指针**：现代C++的内存安全解决方案

掌握引用和指针是理解C++内存模型和高效编程的基础，为学习更高级的语言特性做好准备。