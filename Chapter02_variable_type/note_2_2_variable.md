# 📘 2.2 Section — 变量 (Variables)

> 本章笔记基于《C++ Primer》第五版整理，详细介绍了 C++ 中的变量系统。

---

## 🧠 本章核心概念

- ✯ 变量的基本概念
- ✯ 变量定义 (Variable Definitions)
  - 变量定义语法
  - 初始化器 (Initializers)
  - 列表初始化 (List Initialization)
  - 默认初始化 (Default Initialization)
- ✯ 变量声明与定义 (Variable Declarations and Definitions)
  - 声明 vs 定义的区别
  - extern 关键字
  - 分离式编译支持
- ✯ 标识符 (Identifiers)
  - 标识符命名规则
  - 关键字和保留字
  - 变量命名约定
- ✯ 名字的作用域 (Scope of a Name)
  - 全局作用域 vs 块作用域
  - 嵌套作用域
  - 作用域操作符

---

## ✅ 变量的基本概念

**变量**为我们的程序提供了可以操作的具名存储。C++ 中每个变量都有类型，类型决定了：
- 变量内存的大小和布局
- 可以存储在该内存中的值的范围
- 可以应用于该变量的操作集合

**术语说明**：C++ 程序员倾向于将"变量"和"对象"这两个术语互换使用。

### 📝 对象的定义

**对象**是内存中具有类型的区域。更具体地说：
- **广义定义**：对象是内存中可以包含数据并具有类型的区域
- **狭义定义**：对象是类(class)类型的变量或值
- **使用约定**：本书采用广义定义，无论是内置类型还是类类型、是否有名字、是否可读写，都称为对象

---

## ✅ 变量定义 (Variable Definitions)

### 📝 基本语法

**简单变量定义**由**类型说明符**、一个或多个用逗号分隔的**变量名**组成，以**分号**结尾:

```cpp
int sum = 0, value,           // sum, value, units_sold 都是 int 类型
    units_sold = 0;           // sum 和 units_sold 初始值为 0
Sales_item item;              // item 是 Sales_item 类型
std::string book("0-201-78345-X");  // book 从字符串字面值初始化
```

### 📝 初始化器 (Initializers)

- 定义可以（可选地）为变量提供**初始值**：
- **初始化器（initializer）**是你在定义变量或引用时用来赋初始值的表达式。

```cpp
// 正确：price 在初始化 discount 之前已定义
double price = 109.99, discount = price * 0.16;
// 正确：调用 applyDiscount 并用返回值初始化 salePrice
double salePrice = applyDiscount(price, discount);
```

**重要概念**：
- **初始化不是赋值**：初始化在对象创建时给予值，赋值是用新值替换对象当前值
- 在 C++ 中这个区别很重要，特别是在处理类对象时

#### ⚠️ 警告
初始化不是赋值。初始化发生在变量创建时给定值，赋值会清除对象的当前值并用新值替换。

### 📝 列表初始化 (List Initialization)

C++ 新标准引入的**列表初始化**形式，使用花括号：

```cpp
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```

**内置类型的重要特性**：当用于初始化内置类型变量时，如果初始化器可能导致信息丢失，编译器会报错：

```cpp
long double ld = 3.1415926536;
int a{ld}, d = ld;    // 错误：转换未执行，因为存在丢失信息的风险
int c(ld);            // 正确：转换执行，值被截断
```

### 📝 默认初始化 (Default Initialization)

当定义变量时没有指定初始化器，变量被**默认初始化**， 被初始化为什么默认值取决于初始**类型**，和被**初始化的位置**：

**内置类型的默认初始化**：
- **函数体外定义**：初始化为 0
- **函数体内定义**：**未初始化**，具有未定义的值， 尝试去访问未定义的值会报错。

**类类型的默认初始化**：
- 大多数类允许不显式初始化对象，类会提供合适的默认值
- 例如：`std::string` 默认初始化为空字符串

```cpp
std::string empty;        // empty 隐式初始化为空字符串
Sales_item item;          // 默认初始化的 Sales_item 对象
```

#### ⚠️ 注意事项
- 某些类要求每个对象都必须显式初始化，编译器会在尝试创建无初始化器的此类对象时报错
- **未初始化的内置类型变量**具有未定义值，使用未定义值是难以调试的错误
- 类类型对象在我们没有初始化的情况下会拥有被这个类定义的值

#### ⚠️ 重要警告：未初始化变量导致运行时问题
未初始化变量具有不确定的值。尝试使用未初始化变量的值是一个难以调试的错误。有时程序会在访问对象时立即崩溃，有时程序看起来能正常工作但会产生错误结果。

#### 💡 建议
我们建议初始化每个内置类型对象。虽然不总是必要的，但提供初始化器更容易且更安全，直到你确定省略初始化器是安全的。

---

## ✅ 变量声明与定义 (Variable Declarations and Definitions)

为了支持**分离式编译**，C++ 区分了**声明**和**定义**：

### 📝 基本概念

- **声明 (Declaration)**：使名字为程序所知，指定变量的**类型**和**名字**
- **定义 (Definition)**：不仅可以声明，还可以创建与名字关联的实体，分配**存储空间**，可能提供初始值

**关系**：变量定义也是声明，但声明不一定是定义。

### 📝 extern 关键字

- 要获得**不是定义的声明**，使用 `extern` 关键字且不提供显式初始化器
- 我们可以给用 `extern` 声明的变量提供初始化器，但这将使它变成定义，从而覆盖掉 `extern` 的效果。换句话说 带有初始化器的 `extern` 声明，其实就是一个定义。

```cpp
extern int i;        // 声明但不定义 i
int j;               // 声明并定义 j
extern double pi = 3.1416;  // 定义（extern 有初始化器时覆盖效果）
```

#### ⚠️ 重要规则
- 在函数内部提供 `extern` 初始化器是错误的
- 变量必须**恰好定义一次**，但可以**声明多次**

### 📝 分离式编译的意义

分离式编译使我们能将程序分割为多个文件，每个文件可以独立编译。当多个文件需要共享代码时：
- 在一个文件中定义变量
- 在其他需要使用该变量的文件中声明该变量

#### 📝 注意
- 变量必须**恰好定义一次**，但可以**声明多次**。
- C++是**静态类型语言(Static typed language)**，会在编译过程检查变量类型是否正确，以及类型是否支持我们对该变量的操作，如果类型不允许则会报错。

---

## ✅ 标识符 (Identifiers)

### 📝 命名规则

**标识符**由字母、数字和下划线字符组成：
- 必须以**字母**或**下划线**开头
- 大小写敏感：`somename`、`someName`、`SomeName` 是不同的标识符
- 长度无限制

```cpp
// 定义四个不同的 int 变量
int somename, someName, SomeName, SOMENAME;
```

### 📝 保留字限制

C++ 保留了一些名字供自己使用：
- **关键字**（如 `int`、`class` 等）不能用作标识符
- **标准库保留字**也不应该使用

#### 📝 约定限制
- 用户定义的标识符不能包含**两个连续下划线**
- 不能以**下划线后跟大写字母**开头
- 函数外定义的标识符不能以**下划线**开头

### 📝 变量命名约定

**通用约定**：
- 标识符应该能表达其含义
- 变量名通常使用**小写字母**：`index`，而不是 `Index` 或 `INDEX`
- 类名通常以**大写字母**开头：`Sales_item`
- 多单词标识符应该用视觉方式区分各单词：`student_loan` 或 `studentLoan`

#### ⭐ 最佳实践
命名约定在**一致遵循**时最有用。

---

## ✅ 名字的作用域 (Scope of a Name)

### 📝 基本概念

**作用域**是程序中名字具有特定含义的部分。C++ 中大多数作用域由**花括号**界定。

**名字的可见性**：
- 名字从声明点开始直到作用域结束都是可见的
- 不同作用域中可以使用相同的名字

### 📝 作用域类型

#### 全局作用域 (Global Scope)
在任何花括号外声明的名字具有**全局作用域**：
- 程序中可以访问全局作用域中的名字
- 示例：`main` 函数具有全局作用域

#### 块作用域 (Block Scope)
在花括号内定义的名字具有**块作用域**：
- 只能从声明点到块结束处访问
- 示例：函数参数和函数体内的变量

```cpp
#include <iostream>
int main()
{
    int sum = 0;           // sum 在块作用域中定义
    for (int val = 1; val <= 10; ++val)  // val 在 for 语句的作用域中
        sum += val;        // 等价于 sum = sum + val
    std::cout << "Sum of 1 to 10 inclusive is "
              << sum << std::endl;
    return 0;
}
```

**分析**：
- `main`：全局作用域
- `sum`：在 `main` 函数体的块作用域中定义
- `val`：在 `for` 语句的块作用域中定义

### 📝 嵌套作用域 (Nested Scopes)

- 作用域可以包含其他作用域，被包含的作用域称为**内层作用域**，包含它的作用域称为**外层作用域**。
- 一旦名字被作用域定义，那么内存作用域也可以使用， 也可以在内层作用域重新定义（但是使用相同名字不是好习惯）

```cpp
#include <iostream>
int reused = 42;    // reused 具有全局作用域
int main()
{
    int unique = 0;  // unique 具有块作用域
    // 输出 #1：使用全局的 reused；打印 42 0
    std::cout << reused << " " << unique << std::endl;
    int reused = 0;  // 新的局部对象名为 reused，隐藏了全局的 reused
    // 输出 #2：使用局部的 reused；打印 0 0
    std::cout << reused << " " << unique << std::endl;
    // 输出 #3：显式请求全局的 reused；打印 42 0
    std::cout << ::reused << " " << unique << std::endl;
    return 0;
}
```

#### 📝 作用域操作符 (Scope Operator)

**作用域操作符** (`::`) 可以覆盖默认的作用域规则：
- `::name`：请求全局作用域中的 `name`
- 当作用域操作符左侧为空时，向全局作用域请求右侧的名字

### 📝 建议：在首次使用处定义变量

通常在变量首次使用的地方附近定义变量是个好主意：
- **提高可读性**：使变量定义易于找到
- **便于初始化**：通常更容易给变量一个有用的初始值

---

## 🍃 小结

### 📚 核心知识体系

**变量系统基础**：
- 变量提供具名存储，类型决定存储特性和操作集合
- 对象是内存中具有类型的区域，变量和对象概念可互换使用
- 初始化在对象创建时发生，与赋值有本质区别

**初始化机制**：
- 多种初始化语法：直接初始化、拷贝初始化、列表初始化
- 列表初始化提供类型安全的转换检查
- 默认初始化行为依赖于类型和定义位置

### ⚡ 关键概念精要

**声明与定义**：
- 声明使名字为程序所知，定义创建实体并分配存储
- extern 关键字支持分离式编译，变量必须恰好定义一次
- 理解声明/定义区别是模块化编程的基础

**标识符规范**：
- 标识符命名规则：字母/下划线开头，包含字母/数字/下划线
- 避免使用保留字和特殊约定（双下划线、下划线+大写字母等）
- 良好的命名约定提升代码可读性和维护性

**作用域管理**：
- 全局作用域 vs 块作用域的可见性规则
- 嵌套作用域中的名字隐藏机制
- 作用域操作符提供显式访问全局名字的能力

### 🛡️ 实践防护策略

**初始化安全**：
- **始终初始化内置类型变量**：避免未定义值的运行时错误
- **优先使用列表初始化**：获得编译时类型安全检查
- **在首次使用处定义**：提高代码可读性和初始化效率

**作用域最佳实践**：
- 尽可能缩小变量作用域，在需要时才定义
- 避免全局变量，减少命名冲突和意外修改
- 注意嵌套作用域中的名字隐藏，必要时使用作用域操作符

**代码质量保障**：
- 遵循一致的命名约定，提升团队协作效率
- 理解分离式编译，正确使用声明和定义
- 重视未初始化变量的潜在危险，采用防御性编程策略

### 🔗 学习路径指引

变量系统为后续概念建立基础：
- **复合类型**：引用和指针的变量语义
- **类和对象**：用户定义类型的构造和初始化
- **作用域和生存期**：自动、静态和动态存储管理
- **模板和泛型编程**：类型参数化的变量和对象

掌握变量的定义、初始化和作用域规则是编写健壮C++程序的基础，为理解更复杂的语言特性做好准备。